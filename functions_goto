# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by entering only a number
#
# global variables
script_dir=`pwd`; #get script directory in order to build the paths of the supporting files
r_hist_file=$script_dir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$script_dir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
hist_file=$script_dir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
#
function gotoDir {
# This function closes all existing Finder windows and opens a new finder window with the directory mentioned in the first argument; any other arguments are ignored
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
temp_file=$script_dir/.temp; #temporary file used for updating the history file with the new entry (new previous current directory)
r_hist_max_rows=5; #maximum number of entries allowed in the recent history file
p_hist_max_rows=20; #maximum number of entries allowed in the persistent history file

clear; 
#
# Step 1: check if an argument was entered and the argument is valid (entered path exists and is a directory); check if the history files exist
#
if [[ -z $1 ]]; then 
    echo "No arguments entered. Script aborted.";
    return 1;
fi	 
#
if [[ ! -d $1 ]]; then 
    echo "Invalid directory $1. It might not exist or have been deleted";
    return 1;  
fi
#
if [[ ! -f $r_hist_file ]]; then
   touch "$r_hist_file"; #create the history file of the most recent visits if it does not already exist
fi
if [[ ! -f $p_hist_file ]]; then
    touch "$p_hist_file"; #same for the persistent history file
fi
#
# Step 2: memorize current directory and cd to the new directory
#
prev_dir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
cd "$1";
#
# Step 3: close Finder if cd to the new dir had been successful
#
if [[ $? != 0 ]]; then 
    echo "Error! Cannot change the directory to $1. Script aborted.";
    return 1;  
else
    osascript -e 'quit app "Finder"'; #quit Finder
fi
#
# Step 4: re-open Finder in the new directory if previous close operation had been succesful;
# Then check if re-open was successful:
# a) if not, make an attempt to repeat the re-open operation
#    - if it fails again, then issue error and terminate script
#    - if re-open was successful, proceed to step 5
# b) if yes, proceed to step 5
if [[ $? != 0 ]]; then 
    echo 'Error when closing Finder. Script aborted.';
    open â€“a terminal; #ensure the terminal stays in the foreground
    return 1;
else
    open . 2> /dev/null; #open the desired folder in Finder (supress error as it will be handled in the next step)
    sleep 0.5; #delay further operations so user does not enter a new path before the directory is completely opened
fi
#
if [[ $? != 0 ]]; then
    sleep 1.5; #additional delay so the user doesn't attempt to re-run the command too soon (otherwise the Finder might crash)
    echo "Error! Cannot open directory $1 in Finder."; #if reopening fails, issue error and terminate script
    echo "Reverting to previous directory $prev_dir.";
    echo 'Please try again.';
    cd - > /dev/null;
    return 1;
fi
#
# Step 5: if re-open was successful, update the history file (otherwise revert to the previous current directory)
# This file update is done in 2 ways:
# a) If path of previous directory already exists in the history file, it is moved from its current position (row) to the first row; all other paths follow (in the same order relative to each other as before)
# b) If path of previous directory is not contained in the history file, it is pushed to the first position of the file; each other path is pushed onto the next row
#
echo "Previous directory: $prev_dir"; 
echo "Opened directory: `pwd`";
nr_of_rows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
matched_row=`grep -xn "$prev_dir" "$r_hist_file"`;
if [[ $? == 0 ]]; then #remove previous current directory path from history file if path is contained
    matched_row_nr=`echo $matched_row | cut -f 1 -d : `; 
    sed "$matched_row_nr"'d' "$r_hist_file" > "$temp_file";
elif [[ $nr_of_rows -eq $r_hist_max_rows ]]; then #if number of rows is at maximum, remove a row to make room for the new entry
    sed "$r_hist_max_rows"'d' "$r_hist_file" > "$temp_file";
else
    cp "$r_hist_file" "$temp_file"; #copy the history file to temporary file to maintain consistency
fi
echo "$prev_dir" > "$r_hist_file";
cat "$temp_file" >> "$r_hist_file";
rm "$temp_file"; #remove the temporary file, no longer needed
#
# Step 6: update the persistent history file, then sort it in reverse order by number of visits
#
p_hist_matched_row=`grep "$prev_dir;" "$p_hist_file"`; #use the ';' separator for the grep in order to avoid multiple matches
# if path already exists in the persistent history file, increase the number of visits (otherwise append to end of file)
if [[ $? == 0 ]]; then
    extracted_path=`echo $p_hist_matched_row | cut -f 1 -d ';'`;
    visit_count=`echo $p_hist_matched_row | cut -f 2 -d ';'`;
    let "visit_count=visit_count+1";
    p_hist_replacing_row="$extracted_path"';'"$visit_count";
    sed -e "s+$p_hist_matched_row+$p_hist_replacing_row+g" "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
else
    echo "$prev_dir;1" >> "$p_hist_file";
fi
# sort the paths by number of visits (most visited dirs come first)
sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
mv "$temp_file" "$p_hist_file";
#
# Step 7: consolidate the recent and persistent history into a single file for a unified user access
#
cat "$r_hist_file" > "$hist_file";
head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
#no matter how the function works the terminal must remain the active window after the script finishes execution
open -a terminal;
}
#
function gthist {
# This function reads a line from the .goto_history file and feeds it as argument to the goto function so the user navigates to that directory
#
# Step 0: display the history file and prompt the user to choose one of the entries (or clear the history file/quit)
clear;
if [[ ! -s "$hist_file" ]]; then
    echo 'Empty history file!';
    return 0; 
fi
cat -n "$hist_file";
echo;
echo 'Enter the number of the directory you want to navigate to';
echo 'Enter q or Q to quit, c or C to clear the history file';
echo; 
read dir_nr; 
# Step 1: check the input entered by user. If should be a number between 1 and 10 (there are maximum 10 lines in the history file), clear or quit. Clear history or quit if required.  
#
while [[ $dir_nr != '1'  ]] &&
      [[ $dir_nr != '2'  ]] &&
      [[ $dir_nr != '3'  ]] &&
      [[ $dir_nr != '4'  ]] &&
      [[ $dir_nr != '5'  ]] &&
      [[ $dir_nr != '6'  ]] &&
      [[ $dir_nr != '7'  ]] &&
      [[ $dir_nr != '8'  ]] &&
      [[ $dir_nr != '9'  ]] &&
      [[ $dir_nr != '10' ]] &&
      [[ $dir_nr != '11' ]] &&
      [[ $dir_nr != '12' ]] &&
      [[ $dir_nr != '13' ]] &&
      [[ $dir_nr != '14' ]] &&
      [[ $dir_nr != '15' ]] &&
      [[ $dir_nr != '16' ]] &&
      [[ $dir_nr != '17' ]] &&
      [[ $dir_nr != '18' ]] &&
      [[ $dir_nr != '19' ]] &&
      [[ $dir_nr != '20' ]] &&
      [[ $dir_nr != '21' ]] &&
      [[ $dir_nr != '22' ]] &&
      [[ $dir_nr != '23' ]] &&
      [[ $dir_nr != '24' ]] &&
      [[ $dir_nr != '25' ]] &&
      [[ $dir_nr != 'c'  ]] &&
      [[ $dir_nr != 'C'  ]] &&
      [[ $dir_nr != 'q'  ]] &&
      [[ $dir_nr != 'Q'  ]] ;
do
      echo 'Invalid value! Please try again.';
      echo; 
      read dir_nr;
done
#
if [[ $dir_nr == 'q' ]] || [[ $dir_nr == 'Q' ]]; then
      clear; 
      echo 'Aborted!';
      return 0;
fi
#
if [[ $dir_nr == 'c' ]] || [[ $dir_nr == 'C' ]]; then
      > "$hist_file";
      clear; 
      echo 'The history file content has been flushed.';
      return 0; 
fi
#
# Step 2: read the line from the history file
#
dir_path=`sed "$dir_nr"'q;d' "$hist_file"`;
#
# Step 3: if the line contains a valid directory path, then it is fed as argument to the goto function (this check is done for the situation when only a part of 10 lines are contained in the history file as the user has navigated to less than 10 directories) 
#
if [[ ! -d "$dir_path" ]]; then
    echo "Error! No valid directory on line $dir_nr of $hist_file.";
    echo 'The directory might have been moved or deleted.';
    return 1;
fi
goto "$dir_path";
return 0; 
}

function goToPrevDir {
#
# Step 1: check that the consolidated history file contains at least one entry (first entry is the one of the previous directory)
#
if [[ ! -s "$hist_file" ]]; then
    echo 'Empty history file!';
    return 1;
fi
#
# Step 2: read the line from the history file
#
dir_path=`sed '1q;d' "$hist_file"`;
#
# Step 3: if the line contains a valid directory path, then it is fed as argument to the goto function
#
if [[ ! -d "$dir_path" ]]; then
    echo "Error! No valid directory on line $dir_nr of $hist_file.";
    echo 'The directory might have been moved or deleted.';
    return 1;
fi
gotoDir "$dir_path";
return 0;
}
