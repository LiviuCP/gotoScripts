# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by entering only a number
#
# global variables
script_dir=`pwd`; #get script directory in order to build the paths of the supporting files
r_hist_file=$script_dir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$script_dir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
e_hist_file=$script_dir/.excluded_history; #file containing the entries excluded from the persistent history file due to the fact that they had been added to favorites
hist_file=$script_dir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$script_dir/.goto_favorites; #file containing the directories saved to favorites
format_file=$script_dir/.goto_format; #file used for formatting output (either the content of the favorites file or the content of the consolidated history file)
r_hist_max_rows=5; #maximum number of entries allowed in the recent history file
p_hist_max_rows=20; #maximum number of entries allowed in the persistent history file
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a number
#
function gotoDir {
# This function closes all existing Finder windows and opens a new finder window with the directory mentioned in the first argument; any other arguments are ignored
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
delay_before_close=0.2; #number of seconds of delay before using osascript to close the Finder window
delay_after_reopen=0.3; #number of seconds of delay after re-opening the Finder window
delay_error_reopen=1.5; #number of seconds of delay when an error occurs at Finder re-opening
temp_file=$script_dir/.temp; #temporary file used for updating the history file with the new entry (new previous current directory)

clear; 
#
# Step 1: check if an argument was entered and the argument is valid (entered path exists and is a directory); check if the history files exist
#
if [[ -z $1 ]]; then 
    echo "No arguments entered. Script aborted.";
    return 1;
fi	 
#
if [[ ! -d $1 ]]; then 
    echo "Invalid directory $1. It might not exist or have been deleted";
    return 1;  
fi
#
if [[ ! -f $r_hist_file ]]; then
   touch "$r_hist_file"; #create the history file of the most recent visits if it does not already exist
fi
if [[ ! -f $p_hist_file ]]; then
    touch "$p_hist_file"; #same for the persistent history file
fi
#
# Step 2: memorize current directory and cd to the new directory
#
prev_dir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
cd "$1";
#
# Step 3: close Finder if cd to the new dir had been successful
#
if [[ $? != 0 ]]; then 
    echo "Error! Cannot change the directory to $1. Script aborted.";
    return 1;  
else
    sleep $delay_before_close; #enter a delay to prevent any unwanted behavior (in case the script has just been run and the Finder window re-opening process is not complete)
    osascript -e 'quit app "Finder"'; #quit Finder
fi
#
# Step 4: re-open Finder in the new directory if previous close operation had been succesful;
# Then check if re-open was successful:
# a) if not, make an attempt to repeat the re-open operation
#    - if it fails again, then issue error and terminate script
#    - if re-open was successful, proceed to step 5
# b) if yes, proceed to step 5
if [[ $? != 0 ]]; then 
    echo 'Error when closing Finder. Script aborted.';
    open â€“a terminal; #ensure the terminal stays in the foreground
    return 1;
else
    open . 2> /dev/null; #open the desired folder in Finder (supress error as it will be handled in the next step)
    sleep $delay_after_reopen; #delay further operations so user does not enter a new path before the directory is completely opened
fi
#
if [[ $? != 0 ]]; then
    sleep $delay_error_reopen; #additional delay so the user doesn't attempt to re-run the command too soon (otherwise the Finder might crash)
    echo "Error! Cannot open directory $1 in Finder."; #if reopening fails, issue error and terminate script
    echo "Reverting to previous directory $prev_dir.";
    echo 'Please try again.';
    cd - > /dev/null;
    return 1;
fi
#
# Step 5: if re-open was successful and cd was done to a different directory than the previous one, update the recent history file
#
echo "Previous directory: $prev_dir"; 
echo "Opened directory: `pwd`";
# don't touch history files if the current directory had remained unchanged (no more actions required, skip all further steps)
current_dir=`pwd`;
if [[ $current_dir == $prev_dir ]]; then
    echo;
    echo 'The current directory remained unchanged!';
    echo;
    open -a terminal;
    return 0;
fi
nr_of_rows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
matched_row=`grep -xn "$current_dir" "$r_hist_file"`;
if [[ $? == 0 ]]; then #remove previous current directory path from history file if path is contained
    matched_row_nr=`echo $matched_row | cut -f 1 -d : `; 
    sed "$matched_row_nr"'d' "$r_hist_file" > "$temp_file";
elif [[ $nr_of_rows -eq $r_hist_max_rows ]]; then #if number of rows is at maximum, remove a row to make room for the new entry
    sed "$r_hist_max_rows"'d' "$r_hist_file" > "$temp_file";
else
    cp "$r_hist_file" "$temp_file"; #copy the history file to temporary file to maintain consistency
fi
echo "$current_dir" > "$r_hist_file";
cat "$temp_file" >> "$r_hist_file";
rm "$temp_file"; #remove the temporary file, no longer needed
#
# Step 6: check if the entry already exists in the persistent history file
# - if yes: update the persistent history file, then sort it in reverse order by number of visits
# - if not, check if included in excluded history file
#   - if yes: update the excluded history file by incrementing the number of visits for the directory (no sorting required)
#   - if not: add the entry to persistent history file and sort the file
p_hist_matched_row=`grep "$current_dir"';' "$p_hist_file"`; #use the ';' separator for the grep in order to avoid multiple matches
if [[ $? == 0 ]]; then
    extracted_path=`echo $p_hist_matched_row | cut -f 1 -d ';'`;
    visitsCount=`echo $p_hist_matched_row | cut -f 2 -d ';'`;
    let "visitsCount=visitsCount+1";
    p_hist_replacing_row="$extracted_path"';'"$visitsCount";
    sed -e "s+$p_hist_matched_row+$p_hist_replacing_row+g" "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
elif [[ -f "$e_hist_file" ]]; then
    e_hist_matched_row=`grep "$current_dir"';' "$e_hist_file"`;
    if [[ $? == 0 ]]; then
	extracted_path=`echo $e_hist_matched_row | cut -f 1 -d ';'`;
	visitsCount=`echo $e_hist_matched_row | cut -f 2 -d ';'`;
	let "visitsCount=visitsCount+1";
	e_hist_replacing_row="$extracted_path"';'"$visitsCount";
	sed -e "s+$e_hist_matched_row+$e_hist_replacing_row+g" "$e_hist_file" > "$temp_file";
	mv "$temp_file" "$e_hist_file";
    else
	echo "$current_dir;1" >> "$p_hist_file";
	sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	mv "$temp_file" "$p_hist_file";
    fi
else
    echo "$current_dir;1" >> "$p_hist_file";
    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
fi
#
# Step 7: consolidate the recent and persistent history into a single file for a unified user access
#
cat "$r_hist_file" > "$hist_file";
head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
#no matter how the function works the terminal must remain the active window after the script finishes execution
open -a terminal;
}
#
function gthist {
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
#
# Helper functions for display
function formatFileContent {
# formats the content of the consolidated history file or the favorites file; output is written into a file that is used by one of the display functions listed below
    inputFile=$1;
    > "$format_file";
    while read currentEntry;
    do
	currentEntryFormatted=`basename "$currentEntry"`' : '`dirname "$currentEntry"`;
	echo $currentEntryFormatted >> "$format_file";
    done < "$inputFile"
}
function displayHistory {
    tempVar1=`wc -l "$r_hist_file"`;
    tempVar2=`wc -l "$p_hist_file"`;
    rHistEntries=`echo $tempVar1 | cut -f 1 -d ' '`;
    pHistEntries=`echo $tempVar2 | cut -f 1 -d ' '`;
    formatFileContent "$hist_file";
    clear;
    echo 'NAVIGATION HISTORY';
    echo;
    echo '-- RECENTLY VISITED --';
    echo;
    cat -n "$format_file" | head -"$rHistEntries";
    echo;
    echo '-- MOST VISITED --';
    echo;
    cat -n "$format_file" | tail -"$pHistEntries";
    echo;
    echo 'Enter the number of the directory you want to navigate to';
    echo 'Enter t or T to toggle to the favorite directories menu';
    echo 'Enter q or Q to quit, c or C to clear the navigation history menu';
    echo;
}
function displayFavorites {
    formatFileContent "$fav_file";
    clear;
    echo 'FAVORITE DIRECTORIES';
    echo;
    cat -n "$format_file";
    echo;
    echo 'Enter the number of the directory you want to navigate to';
    echo 'Enter t or T to toggle to the navigation history menu';
    echo 'Enter q or Q to quit, c or C to clear the favorite directories menu';
    echo;
}
# Helper function for handling case when the directory chosen for visiting does not exist
function handleMissingDirectory {
    clear;
    echo "Error! No valid directory on line $dir_nr of $input_file.";
    echo 'The directory might have been moved or deleted.';
    while [[ '1' == '1' ]]; do
	echo;
	echo 'Please choose the required action: ';
	echo 'r or R: remove the directory from the menus';
	echo 'm or M: map to an existing directory';
	echo 'q or Q: quit';
	echo;
	read userChoice;
	if [[ $userChoice == 'r' ]] || [[ $userChoice == 'R' ]]; then
	    # remove the entry from recent history (if there)
	    grep -v "$dir_path" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # if consolidated history was queried, remove the entry from persistent history
	    if [[ "$input_file" == "$hist_file" ]]; then
		grep -v "$dir_path"';' "$p_hist_file" > "$temp_file";
		sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
		rm "$temp_file";
	    # otherwise remove the entry from favorites file and excluded history file
	    else
		grep -v "$dir_path"';' "$e_hist_file" > "$temp_file";
		mv "$temp_file" "$e_hist_file";
		grep -v "$dir_path" "$fav_file" > "$temp_file";
		mv "$temp_file" "$fav_file";
	    fi
	    # history should be consolidated again
	    cat "$r_hist_file" > "$hist_file";
	    head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
	    return 0;
	elif [[ $userChoice == 'm' ]] || [[ $userChoice == 'M' ]]; then
	    clear;
	    echo 'Enter the name of the replacing directory: ';
	    read replacing_dir;
	    # the mapping directory should exist and be a valid directory
	    if [[ ! -d "$replacing_dir" ]]; then
		echo "Directory $replacing_dir does not exist or has been deleted. Cannot map the missing directory $dir_path."
		return 1;
	    fi
	    # ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
	    cd "$replacing_dir";
	    replacing_dir=`pwd`;
	    cd - > /dev/null;
	    # identify the file where the path of the directory to be replaced lives
	    if [[ "$input_file" == "$hist_file" ]]; then
		replaced_dir_file="$p_hist_file";
	    else
		replaced_dir_file="$e_hist_file";
	    fi
	    # check if the replacing dir is part of consolidated history, favorites file or none of them (not yet visited or added to favorites)
	    visits_file=''; # the file where the number of visits of the replacing directory will be looked for (no file if not yet visited or added to favorites)
	    grep -x "$replacing_dir" "$hist_file";
	    if [[ $? == 0 ]]; then
		visits_file="$p_hist_file";
	    else
		grep -x "$replacing_dir" "$fav_file";
		if [[ $? == 0 ]]; then
		    visits_file="$e_hist_file";
		fi
	    fi
	    # get number of times the replacing directory has been visited (-1 if not visited/not added to favorites)
	    if [[ "$visits_file" == "$p_hist_file" ]]; then
		replacingDirEntry=`grep "$replacing_dir"';' "$p_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    elif [[ "$visits_file" == "$e_hist_file" ]]; then
		replacingDirEntry=`grep "$replacing_dir"';' "$e_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    else
		replacingDirVisits='-1';
	    fi
	    # remove the entry from recent history (if there)
	    grep -v "$dir_path" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # do the actual mapping operation
	    # - case 1: the replacing directory is not contained in the files (not yet visited/not yet added to favorites) - just do a path replacement
	    if [[ $replacingDirVisits == '-1' ]]; then
		replacedDirMatchedRow=`grep "$dir_path"';' "$replaced_dir_file"`;
		visitsCount=`echo $replacedDirMatchedRow | cut -f 2 -d ';'`;
		replacedDirReplacingRow="$replacing_dir"';'"$visitsCount";
		sed -e "s+$replacedDirMatchedRow+$replacedDirReplacingRow+g" "$replaced_dir_file" > "$temp_file";
		mv "$temp_file" "$replaced_dir_file";
		# if missing dir had been in the persistent history file: re-sort file
		if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
		    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		    mv "$temp_file" "$p_hist_file";
	        # if missing dir had been in the excluded history file: re-create favorites file after update
		else
		    cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		fi
	    fi
	    # history should be consolidated again
	    cat "$r_hist_file" > "$hist_file";
	    head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
	    return 0;
	elif [[ $userChoice == 'q' ]] || [[ $userChoice == 'Q' ]]; then
	    echo 'Aborted!';
	    return 0;
	else
	    clear;
	    echo 'Invalid option. Please try again';
	fi
    done
}
#
# Step 0: choose the file to be used for navigating, check if it is empty, then display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
if [[ "$1" == '-f' ]]; then
    input_file="$fav_file";
    display='displayFavorites';
else
    input_file="$hist_file";
    display='displayHistory';
fi
if [[ ! -s "$input_file" ]]; then
    echo "File $input_file is empty!";
    return 1;
fi
eval "$display";
read dir_nr;
#
# Step 1: check the input entered by user. If should be either:
# - a number between 1 and and the number of entries contained in the file
# - a character that triggers flushing the content of the history file or quitting the function
#
tempVar=`wc -l "$input_file"`;
currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
while [[ '1' == '1' ]];
do
    if [[ $dir_nr =~  $nonNegativeInteger     ]] &&
       [[ $dir_nr -ge 1                       ]] &&
       [[ $dir_nr -le $currentNumberOfEntries ]]; then
	break;
    elif [[ $dir_nr == 'q' ]] || [[ $dir_nr == 'Q' ]]; then
	clear;
	echo 'Aborted!';
	return 0;
    # toggle to the other menu if the user does not find the required entry
    elif [[ $dir_nr == 't' ]] || [[ $dir_nr == 'T' ]]; then
	if [[ "$1" == '-f' ]]; then
	    gthist;
	else
	    gthist -f;
	fi
	return $?;
    elif [[ $dir_nr == 'c' ]] || [[ $dir_nr == 'C' ]]; then
	if [[ "$1" == '-f' ]]; then
	    > "$fav_file";
	else
	    > "$hist_file";
	    > "$r_hist_file";
	    > "$p_hist_file";
	fi
	clear;
	echo "Content of file $input_file has been flushed.";
	return 0;
    else
	displayInputFile;
	echo 'Invalid value! Please try again.';
	echo;
	read dir_nr;
    fi
done
#
# Step 2: read the line from the input file
#
dir_path=`sed "$dir_nr"'q;d' "$input_file"`;
#
# Step 3: if the line of the input file contains a valid directory path, then it is fed as argument to the goto function
#
if [[ ! -d "$dir_path" ]]; then
    handleMissingDirectory;
    return 1;
fi
gotoDir "$dir_path";
return 0; 
}

function goToPrevDir {
#
# Step 1: check that the consolidated history file contains at least one entry (first entry is the one of the previous directory)
#
if [[ ! -s "$hist_file" ]]; then
    echo 'Empty history file!';
    return 1;
fi
#
# Step 2: read the line from the history file
#
dir_path=`sed '1q;d' "$hist_file"`;
#
# Step 3: if the line contains a valid directory path, then it is fed as argument to the goto function
#
if [[ ! -d "$dir_path" ]]; then
    echo "Error! No valid directory on line $dir_nr of $hist_file.";
    echo 'The directory might have been moved or deleted.';
    return 1;
fi
gotoDir "$dir_path";
return 0;
}

function addToFavorites {
#temporary file used for updating the persistent history file if required
temp_file=$script_dir/.temp;
# Step 1: check if the user entered an argument or not
# - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
# - if no argument was entered, the current directory will be added to favorites
if [[ ! -z "$1" ]]; then
    if [[ ! -d "$1" ]]; then
	echo 'The directory does not exist or has been deleted. Cannot add to favorites.';
	return 1;
    fi
    cd "$1";
    dir_to_add=`pwd`;
    cd - > /dev/null;
else
    dir_to_add=`pwd`;
fi

# Step 2: append the path to the favorites file (create it if it does not exist)
function excludeFromPersistentHistory {
    # check if the entry is included in the persistent history file (if yes, move to the excluded history file and re-sort the persistent history file)
    entryToExclude=`grep "$dir_to_add"';' "$p_hist_file"`;
    if [[ $? == 0 ]]; then
	grep -v "$entryToExclude" "$p_hist_file" > "$temp_file";
	# normally sorting would not be required (the persistent history file is already sorted and should remain so; it's just a safety precaution)
	sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	rm "$temp_file";
	# history should be consolidated again
	cat "$r_hist_file" > "$hist_file";
	head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
	# update excluded history file
	echo "$entryToExclude" >> "$e_hist_file";
    else
	# if file is not already included in persistent history, just add it to the excluded history file (with number of visits 0 as the directory hasn't been visited yet)
	echo "$dir_to_add"';0' >> "$e_hist_file";
    fi
}
if [[  -f "$fav_file" ]]; then
    grep -x "$dir_to_add" "$fav_file" > /dev/null;
    if [[ $? != 0 ]]; then
	echo $dir_to_add >> "$fav_file";
	echo "Directory $dir_to_add added to favorites";
	excludeFromPersistentHistory;
	return 0;
    else
	echo "Directory $dir_to_add already added to favorites";
	return 1;
    fi
else
    echo $dir_to_add >> "$fav_file";
    echo "Directory $dir_to_add added to favorites";
    excludeFromPersistentHistory;
    return 0;
fi
}

function removeFromFavorites {
#temporary file used for updating the favorites file and the excluded file when an entry is removed
temp_file=$script_dir/.temp;
# Step 1: check if the favorites file exists and is not empty
if [[ ! -f "$fav_file" ]]; then
    echo "Error! The favorites file $fav_file does not exist or has been deleted";
    return 1;
fi
if [[ ! -s "$fav_file" ]]; then
    echo "File $fav_file is empty! Nothing to remove";
    return 1;
fi
# Step 2: display the file and prompt the user to choose the line to be deleted
function displayFavoritesFile {
clear;
cat -n "$fav_file";
echo;
echo 'Enter the number of the entry to be removed';
echo 'Enter q or Q to quit';
echo;
}
displayFavoritesFile;
read dir_nr;
# Step 3: check the input entered by user. If should be either:
# - a number between 1 and and the number of entries contained in the file
# - a character that triggers quitting the function
#
tempVar=`wc -l "$fav_file"`;
currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
while [[ '1' == '1' ]];
do
    if [[ $dir_nr =~  $nonNegativeInteger     ]] &&
       [[ $dir_nr -ge 1                       ]] &&
       [[ $dir_nr -le $currentNumberOfEntries ]]; then
	break;
    elif [[ $dir_nr == 'q' ]] || [[ $dir_nr == 'Q' ]]; then
	clear;
	echo 'Aborted!';
	return 0;
    else
	displayFavoritesFile;
	echo 'Invalid value! Please try again.';
	echo;
	read dir_nr;
    fi
done
# Step 4: remove the entry from the excluded history file
fav_dir_to_remove=`sed "$dir_nr"'q;d' "$fav_file"`;
excl_dir_to_remove=`grep "$fav_dir_to_remove"';' "$e_hist_file"`;
visitsCount=`echo "$excl_dir_to_remove" | cut -f 2 -d ';'`;
grep -v "$excl_dir_to_remove" "$e_hist_file" > "$temp_file";
mv "$temp_file" "$e_hist_file";
# Also move the entry back to the persistent history file if it has at least one visit
if [[ $visitsCount -gt 0 ]]; then
    echo $excl_dir_to_remove >> "$p_hist_file";
    # Always sort the persistent history file when it is modified
    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
    # history should be consolidated again
    cat "$r_hist_file" > "$hist_file";
    head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
fi
# Step 5: delete the entry
sed "$dir_nr"'d' "$fav_file" > "$temp_file";
mv "$temp_file" "$fav_file";
clear;
echo 'Entry removed from the favorites file';
}
