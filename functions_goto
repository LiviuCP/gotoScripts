# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by entering only a number
#
# global variables
script_dir=`pwd`; #get script directory in order to build the paths of the supporting files
r_hist_file=$script_dir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$script_dir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
hist_file=$script_dir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$script_dir/.goto_favorites; #file containing the directories saved to favorites
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a number
#
function gotoDir {
# This function closes all existing Finder windows and opens a new finder window with the directory mentioned in the first argument; any other arguments are ignored
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
delay_before_close=0.2; #number of seconds of delay before using osascript to close the Finder window
delay_after_reopen=0.3; #number of seconds of delay after re-opening the Finder window
delay_error_reopen=1.5; #number of seconds of delay when an error occurs at Finder re-opening
temp_file=$script_dir/.temp; #temporary file used for updating the history file with the new entry (new previous current directory)
r_hist_max_rows=5; #maximum number of entries allowed in the recent history file
p_hist_max_rows=20; #maximum number of entries allowed in the persistent history file

clear; 
#
# Step 1: check if an argument was entered and the argument is valid (entered path exists and is a directory); check if the history files exist
#
if [[ -z $1 ]]; then 
    echo "No arguments entered. Script aborted.";
    return 1;
fi	 
#
if [[ ! -d $1 ]]; then 
    echo "Invalid directory $1. It might not exist or have been deleted";
    return 1;  
fi
#
if [[ ! -f $r_hist_file ]]; then
   touch "$r_hist_file"; #create the history file of the most recent visits if it does not already exist
fi
if [[ ! -f $p_hist_file ]]; then
    touch "$p_hist_file"; #same for the persistent history file
fi
#
# Step 2: memorize current directory and cd to the new directory
#
prev_dir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
cd "$1";
#
# Step 3: close Finder if cd to the new dir had been successful
#
if [[ $? != 0 ]]; then 
    echo "Error! Cannot change the directory to $1. Script aborted.";
    return 1;  
else
    sleep $delay_before_close; #enter a delay to prevent any unwanted behavior (in case the script has just been run and the Finder window re-opening process is not complete)
    osascript -e 'quit app "Finder"'; #quit Finder
fi
#
# Step 4: re-open Finder in the new directory if previous close operation had been succesful;
# Then check if re-open was successful:
# a) if not, make an attempt to repeat the re-open operation
#    - if it fails again, then issue error and terminate script
#    - if re-open was successful, proceed to step 5
# b) if yes, proceed to step 5
if [[ $? != 0 ]]; then 
    echo 'Error when closing Finder. Script aborted.';
    open â€“a terminal; #ensure the terminal stays in the foreground
    return 1;
else
    open . 2> /dev/null; #open the desired folder in Finder (supress error as it will be handled in the next step)
    sleep $delay_after_reopen; #delay further operations so user does not enter a new path before the directory is completely opened
fi
#
if [[ $? != 0 ]]; then
    sleep $delay_error_reopen; #additional delay so the user doesn't attempt to re-run the command too soon (otherwise the Finder might crash)
    echo "Error! Cannot open directory $1 in Finder."; #if reopening fails, issue error and terminate script
    echo "Reverting to previous directory $prev_dir.";
    echo 'Please try again.';
    cd - > /dev/null;
    return 1;
fi
#
# Step 5: if re-open was successful and cd was done to a different directory than the previous one, update the recent history file
#
echo "Previous directory: $prev_dir"; 
echo "Opened directory: `pwd`";
# don't touch history files if the current directory had remained unchanged (no more actions required, skip all further steps)
current_dir=`pwd`;
if [[ $current_dir == $prev_dir ]]; then
    echo;
    echo 'The current directory remained unchanged!';
    echo;
    open -a terminal;
    return 0;
fi
nr_of_rows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
matched_row=`grep -xn "$prev_dir" "$r_hist_file"`;
if [[ $? == 0 ]]; then #remove previous current directory path from history file if path is contained
    matched_row_nr=`echo $matched_row | cut -f 1 -d : `; 
    sed "$matched_row_nr"'d' "$r_hist_file" > "$temp_file";
elif [[ $nr_of_rows -eq $r_hist_max_rows ]]; then #if number of rows is at maximum, remove a row to make room for the new entry
    sed "$r_hist_max_rows"'d' "$r_hist_file" > "$temp_file";
else
    cp "$r_hist_file" "$temp_file"; #copy the history file to temporary file to maintain consistency
fi
echo "$prev_dir" > "$r_hist_file";
cat "$temp_file" >> "$r_hist_file";
rm "$temp_file"; #remove the temporary file, no longer needed
#
# Step 6: update the persistent history file, then sort it in reverse order by number of visits
#
p_hist_matched_row=`grep "$prev_dir;" "$p_hist_file"`; #use the ';' separator for the grep in order to avoid multiple matches
# if path already exists in the persistent history file, increase the number of visits (otherwise append to end of file)
if [[ $? == 0 ]]; then
    extracted_path=`echo $p_hist_matched_row | cut -f 1 -d ';'`;
    visit_count=`echo $p_hist_matched_row | cut -f 2 -d ';'`;
    let "visit_count=visit_count+1";
    p_hist_replacing_row="$extracted_path"';'"$visit_count";
    sed -e "s+$p_hist_matched_row+$p_hist_replacing_row+g" "$p_hist_file" > "$temp_file";
    mv "$temp_file" "$p_hist_file";
else
    echo "$prev_dir;1" >> "$p_hist_file";
fi
# sort the paths by number of visits (most visited dirs come first)
sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
mv "$temp_file" "$p_hist_file";
#
# Step 7: consolidate the recent and persistent history into a single file for a unified user access
#
cat "$r_hist_file" > "$hist_file";
head -"$p_hist_max_rows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
#no matter how the function works the terminal must remain the active window after the script finishes execution
open -a terminal;
}
#
function gthist {
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
#
# Step 0: choose the file to be used for navigating, check if it is empty, then display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
if [[ "$1" == '-f' ]]; then
    input_file="$fav_file";
else
    input_file="$hist_file";
fi
if [[ ! -s "$input_file" ]]; then
    echo "File $input_file is empty!";
    return 1;
fi
function displayInputFile {
    clear;
    cat -n "$input_file";
    echo;
    echo 'Enter the number of the directory you want to navigate to';
    echo 'Enter q or Q to quit, c or C to flush the input file content';
    echo;
}
displayInputFile;
read dir_nr;
#
# Step 1: check the input entered by user. If should be either:
# - a number between 1 and and the number of entries contained in the file
# - a character that triggers flushing the content of the history file or quitting the function
#
tempVar=`wc -l "$input_file"`;
currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
while [[ '1' == '1' ]];
do
    if [[ $dir_nr =~  $nonNegativeInteger     ]] &&
       [[ $dir_nr -ge 1                       ]] &&
       [[ $dir_nr -le $currentNumberOfEntries ]]; then
	break;
    elif [[ $dir_nr == 'q' ]] || [[ $dir_nr == 'Q' ]]; then
	clear;
	echo 'Aborted!';
	return 0;
    elif [[ $dir_nr == 'c' ]] || [[ $dir_nr == 'C' ]]; then
	if [[ "$1" == '-f' ]]; then
	    > "$fav_file";
	else
	    > "$hist_file";
	    > "$r_hist_file";
	    > "$p_hist_file";
	fi
	clear;
	echo "Content of file $input_file has been flushed.";
	return 0;
    else
	displayInputFile;
	echo 'Invalid value! Please try again.';
	echo;
	read dir_nr;
    fi
done
#
# Step 2: read the line from the input file
#
dir_path=`sed "$dir_nr"'q;d' "$input_file"`;
#
# Step 3: if the line of the input file contains a valid directory path, then it is fed as argument to the goto function
#
if [[ ! -d "$dir_path" ]]; then
    echo "Error! No valid directory on line $dir_nr of $input_file.";
    echo 'The directory might have been moved or deleted.';
    return 1;
fi
gotoDir "$dir_path";
return 0; 
}

function goToPrevDir {
#
# Step 1: check that the consolidated history file contains at least one entry (first entry is the one of the previous directory)
#
if [[ ! -s "$hist_file" ]]; then
    echo 'Empty history file!';
    return 1;
fi
#
# Step 2: read the line from the history file
#
dir_path=`sed '1q;d' "$hist_file"`;
#
# Step 3: if the line contains a valid directory path, then it is fed as argument to the goto function
#
if [[ ! -d "$dir_path" ]]; then
    echo "Error! No valid directory on line $dir_nr of $hist_file.";
    echo 'The directory might have been moved or deleted.';
    return 1;
fi
gotoDir "$dir_path";
return 0;
}

function addToFavorites {
# Step 1: check if the user entered an argument or not
# - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
# - if no argument was entered, the current directory will be added to favorites
if [[ ! -z "$1" ]]; then
    if [[ ! -d "$1" ]]; then
	echo 'The directory does not exist or has been deleted. Cannot add to favorites.';
	return 1;
    fi
    cd "$1";
    dir_to_add=`pwd`;
    cd - > /dev/null;
else
    dir_to_add=`pwd`;
fi
# Step 2: append the path to the favorites file (create it if it does not exist)
if [[  -f "$fav_file" ]]; then
    grep -x "$dir_to_add" "$fav_file" > /dev/null;
    if [[ $? != 0 ]]; then
	echo $dir_to_add >> "$fav_file";
	echo "Directory $dir_to_add added to favorites";
	return 0;
    else
	echo "Directory $dir_to_add already added to favorites";
	return 1;
    fi
else
    echo $dir_to_add >> "$fav_file";
    echo "Directory $dir_to_add added to favorites";
    return 0
fi
}

function removeFromFavorites {
#temporary file used for updating the favorites file when an entry is removed
temp_file=$script_dir/.temp;
# Step 1: check if the favorites file exists
if [[ ! -f "$fav_file" ]]; then
    echo "Error! The favorites file $fav_file does not exist or has been deleted";
    return 1;
fi
# Step 2: display the file and prompt the user to choose the line to be deleted
function displayFavoritesFile {
clear;
cat -n "$fav_file";
echo;
echo 'Enter the number of the entry to be removed';
echo 'Enter q or Q to quit';
echo;
}
displayFavoritesFile;
read dir_nr;
# Step 3: check the input entered by user. If should be either:
# - a number between 1 and and the number of entries contained in the file
# - a character that triggers quitting the function
#
tempVar=`wc -l "$input_file"`;
currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
while [[ '1' == '1' ]];
do
    if [[ $dir_nr =~  $nonNegativeInteger     ]] &&
       [[ $dir_nr -ge 1                       ]] &&
       [[ $dir_nr -le $currentNumberOfEntries ]]; then
	break;
    elif [[ $dir_nr == 'q' ]] || [[ $dir_nr == 'Q' ]]; then
	clear;
	echo 'Aborted!';
	return 0;
    else
	displayFavoritesFile;
	echo 'Invalid value! Please try again.';
	echo;
	read dir_nr;
    fi
done
# Step 4: delete the entry
sed "$dir_nr"'d' "$fav_file" > "$temp_file";
mv "$temp_file" "$fav_file";
clear;
echo 'Entry removed from the favorites file';
}
