# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by choosing the entry number
# - adding directories to favorites menu and enabling jumping to one of these by just choosing the entry number
#
# GLOBAL VARIABLES
#
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
logDir=$scriptDir/.goToLogs; #in this directory the script stores the "log" files which contain the paths of the visited directories for each day
#
r_hist_file=$scriptDir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$scriptDir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
e_hist_file=$scriptDir/.excluded_history; #file containing the entries excluded from the persistent history file due to the fact that they had been added to favorites
#
hist_file=$scriptDir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$scriptDir/.goto_favorites; #file containing the directories saved to favorites
format_file=$scriptDir/.goto_format; #file used for formatting output (either the content of the favorites file or the content of the consolidated history file)
temp_file=$scriptDir/.temp; #temporary file used for various operations (to be removed each time the operation it is used in finishes)
aux_temp_file=$scriptDir/.aux_temp; #auxiliary temporary file (in case the first temp file is not enough)
#
rHistMaxRows=10; #maximum number of entries allowed in the recent history file
pHistMaxRows=15; #maximum number of entries allowed in the persistent history file
maxNrOfItems=50; #maximum number of files/dirs listed from current directory in navigation mode
maxNrOfChars=25; #maximum number of characters to be displayed for each item from current directory in navigation mode
#
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a non-negative number
#
# GLOBAL FUNCTIONS
#
# This is a helper function shared by more of the below global functions (its purpose is to consolidate the persistent and recent history into a single file in a useful manner)
#
function consolidateHistory {
    # first sort the recent history file by name of each directory (not path) and add it to consolidated history
    > "$temp_file";
    while read currentEntry;
    do
	currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	echo "$currentEntryConverted" >> "$temp_file";
    done < "$r_hist_file"
    sort -f "$temp_file" | cut -f 2 -d ':' > "$hist_file";
    rm "$temp_file";
    # do the same for persistent history and append it to consolidated history
    head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' > "$temp_file";
    while read currentEntry;
    do
	currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	echo "$currentEntryConverted" >> "$aux_temp_file";
    done < "$temp_file"
    sort -f "$aux_temp_file" | cut -f 2 -d ':' >> "$hist_file";
    rm "$temp_file";
    rm "$aux_temp_file";
}
#
# This function is only run once (when this file is loaded) and prepares the environment for usage
#
function init {
    # create the required history and favorites files if they don't already exist
    touch "$r_hist_file";
    touch "$p_hist_file";
    touch "$e_hist_file";
    touch "$fav_file";
    # ensure the recent history file has the maximum allowed number of entries
    head -"$rHistMaxRows" "$r_hist_file" > "$temp_file";
    mv "$temp_file" "$r_hist_file";
    # consolidate history (in case the user just modified the number of entries allowed in recent and persistent history)
    consolidateHistory;
    # create log directory if not already existent
    if [[ ! -d "$logDir" ]]; then
	mkdir "$logDir";
    fi
    # ensure the log file for the current day exists; this file tracks all visited directories for the day and ensure they are not added to persistent history more than once
    w_log_file="$logDir"/`date +"%Y%m%d"`;
    touch "$w_log_file";
}
init;
unset -f init;
#
# This function is used for navigating to a new directory by using a cd command
# It also memorizes the visited directories in history files
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
function goToDir {
    #
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory);
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    #
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    #
    # Step 3: check if the cd operation has been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    fi
    #
    # Step 4: if cd was done to a different directory than the previous one, update the recent history file
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	return 0;
    fi
    nrOfRows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
    matchedRow=`grep -xn "$currentDir" "$r_hist_file"`;
    #remove previous current directory path from history file if path is contained
    if [[ $? == 0 ]]; then
	matchedRowNr=`echo $matchedRow | cut -f 1 -d : `;
	sed "$matchedRowNr"'d' "$r_hist_file" > "$temp_file";
    #if number of rows is at maximum, remove a row to make room for the new entry
    elif [[ $nrOfRows -eq $rHistMaxRows ]]; then
	sed "$rHistMaxRows"'d' "$r_hist_file" > "$temp_file";
    #copy the history file to temporary file to maintain consistency with above cases
    else
	cp "$r_hist_file" "$temp_file";
    fi
    echo $currentDir > "$r_hist_file";
    cat "$temp_file" >> "$r_hist_file";
    rm "$temp_file";
    #
	# Step 5: check if the visited directory path is contained in the log file of the current day:
    # - if yes: consolidate history, no more actions required
    # - if not: go to next step
    grep -x "$currentDir" "$w_log_file" > /dev/null;
    if [[ $? == 0 ]]; then
	consolidateHistory;
	return 0;
    else
	echo "$currentDir" >> "$w_log_file";
    fi
    # Step 6: check if the entry already exists in the persistent history file
    # - if yes: update the persistent history file, then sort it in reverse order by number of visits
    # - if not, check if included in excluded history file
    #   - if yes: update the excluded history file by incrementing the number of visits for the directory (no sorting required)
    #   - if not: add the entry to persistent history file and sort the file
    #
    # #use the ';' separator for the grep in order to avoid multiple matches
    pHistMatchedRow=`grep "$currentDir"';' "$p_hist_file"`;
    #
    if [[ $? == 0 ]]; then
	extractedPath=`echo $pHistMatchedRow | cut -f 1 -d ';'`;
	visitsCount=`echo $pHistMatchedRow | cut -f 2 -d ';'`;
	let "visitsCount=visitsCount+1";
	pHistReplacingRow="$extractedPath"';'"$visitsCount";
	grep -v "$pHistMatchedRow" "$p_hist_file" > "$temp_file";
	echo "$pHistReplacingRow" >> "$temp_file";
	sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
    else
	eHistMatchedRow=`grep "$currentDir"';' "$e_hist_file"`;
	if [[ $? == 0 ]]; then
	    extractedPath=`echo $eHistMatchedRow | cut -f 1 -d ';'`;
	    visitsCount=`echo $eHistMatchedRow | cut -f 2 -d ';'`;
	    let "visitsCount=visitsCount+1";
	    eHistReplacingRow="$extractedPath"';'"$visitsCount";
	    grep -v "$eHistMatchedRow" "$e_hist_file" > "$temp_file";
	    echo "$eHistReplacingRow" >> "$temp_file";
	    mv "$temp_file" "$e_hist_file";
	else
	    echo "$currentDir"';1' >> "$p_hist_file";
	    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	    mv "$temp_file" "$p_hist_file";
	fi
    fi
    #
    # consolidate the recent and persistent history into a single file so the user can see both of them in the history menu
    consolidateHistory;
}
#
# ******************************************************************************************************************
#
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Helper functions for display
    #
    # formats the content of the consolidated history file or the favorites file; output is written into a file that is used by one of the display functions listed below
    function formatFileContent {
	input_file=$1;
	> "$format_file";
	while read currentEntry;
	do
	    currentEntryFormatted=`basename "$currentEntry"`':     '"$currentEntry";
	    echo "$currentEntryFormatted" >> "$format_file";
	done < "$input_file"
	column -t -s ':' "$format_file" > "$temp_file";
	mv "$temp_file" "$format_file";
    }
    #displays the consolidated history menu in a convenient manner for the user
    function displayHistory {
	tempVar1=`wc -l "$r_hist_file"`;
	tempVar2=`wc -l "$hist_file"`;
	rHistEntries=`echo $tempVar1 | cut -f 1 -d ' '`;
	histEntries=`echo $tempVar2 | cut -f 1 -d ' '`;
	let pHistEntries=histEntries-rHistEntries;
	formatFileContent "$hist_file";
	clear;
	echo 'NAVIGATION HISTORY';
	echo;
	echo '-- RECENTLY VISITED DIRECTORIES --';
	echo;
	cat -n "$format_file" | head -"$rHistEntries";
	echo;
	echo '--   MOST VISITED DIRECTORIES   --';
	echo;
	cat -n "$format_file" | tail -"$pHistEntries";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	if [[ -s "$fav_file" ]]; then
	    echo 'Press ENTER to toggle to the favorite directories menu.';
	fi
	echo 'Enter :cMenu (case-sensitive) to clear history or :q to quit.';
	echo;
    }
    #displays the favorites menu in a different (tailor-made) manner from the history menu
    function displayFavorites {
	formatFileContent "$fav_file";
	clear;
	echo 'FAVORITE DIRECTORIES';
	echo;
	cat -n "$format_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	if [[ -s "$hist_file" ]]; then
	    echo 'Press ENTER to toggle to the navigation history menu.';
	fi
	echo 'Enter :cMenu (case-sensitive) to clear history or :q to quit.';
	echo;
    }
    # handles the case when the directory chosen for visiting does not exist
    function handleMissingDirectory {
	# working log file for the current day also needs update (if existing and if the entry is present)
	w_log_file="$logDir"/`date +"%Y%m%d"`;
	clear;
	echo "Invalid path $dirPath";
	echo 'The directory might have been moved or deleted.';
	while [[ '1' == '1' ]]; do
	    echo;
	    echo 'Please choose the required action: ';
	    echo ':r to remove the directory from the menus';
	    echo ':m to map to an existing directory';
	    echo ':q to quit';
	    echo;
	    read -e userChoice;
	    # user chooses to remove the entry from menus (consolidated history and/or favorites)
	    if [[ $userChoice == ':r' ]]; then
		# ensure the entry gets removed from the working log file (if the file had been created in the current day)
		if [[ -f "$w_log_file" ]]; then
		    grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		    mv "$temp_file" "$w_log_file";
		fi
		# ensure the entry is removed from recent history (if there)
		grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
		mv "$temp_file" "$r_hist_file";
		# ensure the entry is removed from persistent history (if there)
		grep -v "$dirPath"';' "$p_hist_file" > "$temp_file";
		sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
		rm "$temp_file";
		# ensure the entry is removed from favorites file (if there)
		grep -v "$dirPath"';' "$e_hist_file" > "$temp_file";
		mv "$temp_file" "$e_hist_file";
		grep -xv "$dirPath" "$fav_file" > "$temp_file";
		mv "$temp_file" "$fav_file";
		# history should be consolidated again
		consolidateHistory;
		# confirm removal has been successfully performed
		echo "Entry $dirPath has been removed from the menus.";
		return 0;
	    # user chooses to replace the directory entry with another (existing) path
	    elif [[ $userChoice == ':m' ]]; then
		clear;
		echo 'Enter the name of the replacing directory: ';
		read -e replacingDir;
		# the mapping directory should exist and be a valid directory
		if [[ ! -d "$replacingDir" ]]; then
		    echo "Directory $replacingDir does not exist or has been deleted.";
		    echo "Cannot map the missing directory $dirPath.";
		    return 1;
		fi
		# ensure the entry gets removed from the working log file (if the file had been created in the current day)
		if [[ -f "$w_log_file" ]]; then
		    grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		    mv "$temp_file" "$w_log_file";
		fi
		# ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
		cd "$replacingDir";
		replacingDir=`pwd`;
		cd - > /dev/null;
		# identify the file where the path of the directory to be replaced lives
		grep "$dirPath"';' "$e_hist_file" > /dev/null;
		if [[ $? == 0 ]]; then
		    replaced_dir_file="$e_hist_file";
		else
		    replaced_dir_file="$p_hist_file";
		fi
		# check if the replacing dir is part of consolidated history, favorites file or none of them (not yet visited or added to favorites)
		visits_file=''; # the file where the number of visits of the replacing directory will be looked for (no file if not yet visited or added to favorites)
		foundEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		if [[ $? == 0 ]]; then
		    visits_file="$p_hist_file";
		else
		    foundEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		    if [[ $? == 0 ]]; then
			visits_file="$e_hist_file";
		    fi
		fi
		# get number of times the replacing directory has been visited (-1 if not visited/not added to favorites)
		if [[ "$visits_file" == "$p_hist_file" ]]; then
		    replacingDirEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		    replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
		elif [[ "$visits_file" == "$e_hist_file" ]]; then
		    replacingDirEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		    replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
		else
		    replacingDirVisits='-1';
		fi
		# remove the entry from recent history (if there)
		grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
		mv "$temp_file" "$r_hist_file";
		# do the actual mapping operation
		replacedDirMatchedRow=`grep "$dirPath"';' "$replaced_dir_file"`;
		replacedDirVisits=`echo $replacedDirMatchedRow | cut -f 2 -d ';'`;
		# - case 1: the replacing directory is not contained in the files (not yet visited/not yet added to favorites) - just do a path replacement
		if [[ $replacingDirVisits == '-1' ]]; then
		    replacedDirReplacingRow="$replacingDir"';'"$replacedDirVisits";
		    grep -v "$replacedDirMatchedRow" "$replaced_dir_file" > "$temp_file";
		    echo "$replacedDirReplacingRow" >> "$temp_file";
		    mv "$temp_file" "$replaced_dir_file";
		    # if missing dir had been in the persistent history file: re-sort file
		    if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
			sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
			mv "$temp_file" "$p_hist_file";
			# if missing dir had been in the excluded history file: re-create favorites file after update
		    else
			cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    fi
		# - case 2: the replacing directory is contained either in the persistent history file or in the favorites file
		else
		    # if the number of visits of the dir to be replaced exceeds the one of the replacing dir, then update the number of visits of the replacing dir to the higher figure
		    if [[ $replacingDirVisits -lt $replacedDirVisits ]]; then
			replacingDirPath=`echo $replacingDirEntry | cut -f 1 -d ';'`;
			replacingDirReplacingRow="$replacingDirPath"';'"$replacedDirVisits";
			grep -v "$replacingDirEntry" "$visits_file" > "$temp_file";
			echo "$replacingDirReplacingRow" >> "$temp_file";
			mv "$temp_file" "$visits_file";
		    fi
		    # remove the replaced directory from its file (either persistent history or excluded history file)
		    grep -v "$dirPath"';' "$replaced_dir_file" > "$temp_file";
		    mv "$temp_file" "$replaced_dir_file";
		    # if missing dir had been in the persistent history file: re-sort file
		    if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
			sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
			mv "$temp_file" "$p_hist_file";
		    # if missing dir had been in the excluded history file: re-create favorites file after update
		    else
			cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    fi
		fi
		# history should be consolidated again
		consolidateHistory;
		# confirm mapping has been successfully performed
		echo "Missing directory: $dirPath";
		echo "Replacing directory: $replacingDir";
		echo 'Mapping performed successfully.';
		return 0;
	    elif [[ $userChoice == ':q' ]]; then
		clear;
		echo "You exited the $menuType menu.";
		return 0;
	    else
		clear;
		echo 'Invalid option! Please try again.';
	    fi
	done
    }
    # unsets all helper functions so they are not accessible by user from CLI
    # should be called before the main function returns, otherwise the helpers might become inaccessible earlier than required
    # the unsetHelpers function should be itself unset (right after it runs)
    function unsetHelpers {
	unset -f formatFileContent;
	unset -f displayHistory;
	unset -f displayFavorites;
	unset -f handleMissingDirectory;
    }
    #
    # Step 0: choose the file to be used for navigating, check if it is empty, (if not) display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
    if [[ "$1" == '-f' ]]; then
	input_file="$fav_file";
	display='displayFavorites';
	menuType='favorites';
    else
	input_file="$hist_file";
	display='displayHistory';
	menuType='history';
    fi
    #
    if [[ ! -s "$input_file" ]]; then
	echo "There are no entries in the $menuType menu.";
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    eval "$display";
    read -e dirNr;
    #
    # Step 1: check the input entered by user. If should be either:
    # - a number between 1 and and the number of entries contained in the file
    # - a character that triggers flushing the content of the favorites/history file, switching to the other file or quitting the function
    tempVar=`wc -l "$input_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    while [[ '1' == '1' ]];
    do
	# check if the user chose one of the entries from the history or favorites file
	if [[ $dirNr =~  $nonNegativeInteger     ]] &&
	   [[ $dirNr -ge 1                       ]] &&
	   [[ $dirNr -le $currentNumberOfEntries ]]; then
	    break;
	# user chooses to quit the function
	elif [[ $dirNr == ':q' ]]; then
	    clear;
	    echo "You exited the $menuType menu.";
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 0;
	# toggle to the other menu if the user chooses so
	elif [[ -z "$dirNr" ]]; then
	    if [[ "$1" == '-f' ]]; then
		if [[ ! -s "$hist_file" ]]; then
		    eval "$display";
		    echo 'Toggling disabled: no entries in the history menu.';
		    echo 'Please enter one of the valid options listed above.';
		    echo;
		    read -e dirNr;
		else
		    goToMenu;
		    unsetHelpers 2> /dev/null;
		    unset -f unsetHelpers;
		    return $?;
		fi
	    else
		if [[ ! -s "$fav_file" ]]; then
		    eval "$display";
		    echo 'Toggling disabled: no entries in the favorites menu.';
		    echo 'Please enter one of the valid options listed above.';
		    echo;
		    read -e dirNr;
		else
		    goToMenu -f;
		    unsetHelpers 2> /dev/null;
		    unset -f unsetHelpers;
		    return $?;
		fi
	    fi
	# clear history (persistent, recent, excluded) if the user chooses to
	elif [[ $dirNr == ':cMenu' ]]; then
	    > "$hist_file";
	    > "$r_hist_file";
	    > "$p_hist_file";
	    > "$e_hist_file";
	    # the working log file also needs to be reset to ensure consistency with the history content
	    w_log_file="$logDir"/`date +"%Y%m%d"`;
	    if [[ -f "$w_log_file" ]]; then
		> "$w_log_file";
	    fi
	    # favorites file should be kept so excluded history should be re-created (0 visits per entry)
	    while read currentEntry;
	    do
		echo "$currentEntry"';0' >> "$e_hist_file";
	    done < "$fav_file"
	    clear;
	    echo 'Content of navigation history menu has been erased.';
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 0;
	else
	    eval "$display";
	    echo 'Invalid option! Please try again.';
	    echo;
	    read -e dirNr;
	fi
    done
    #
    # Step 2: read the line from the input file
    dirPath=`sed "$dirNr"'q;d' "$input_file"`;
    #
    # Step 3: if the line of the input file contains a valid directory path, then visit the directory
    if [[ ! -d "$dirPath" ]]; then
	handleMissingDirectory;
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    goToDir "$dirPath";
    unsetHelpers 2> /dev/null;
    unset -f unsetHelpers;
}
#
# ******************************************************************************************************************
#
# used for returning to the previously visited directory without needing to access the history or favorites menus
function goToPrevDir {
    if [[ $prevDir == '' ]]; then
	echo 'Cannot jump to previous directory.';
	echo 'No directory visited in the current session.';
	return 1;
    fi
    goToDir "$prevDir";
}
#
# ******************************************************************************************************************
#
# used for adding a directory (either the current one or another) to favorites
function addToFavorites {
    #
    # Step 1: check if the user entered an argument or not
    # - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
    # - if no argument was entered, the current directory will be added to favorites
    if [[ ! -z "$1" ]]; then
	if [[ ! -d "$1" ]]; then
	    echo "Directory $1 does not exist or has been deleted.";
	    echo 'Cannot add to favorites.';
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
	cd "$1";
	dirToAdd=`pwd`;
	cd - > /dev/null;
    else
	dirToAdd=`pwd`;
    fi
    #
    # Step 2: append the path to the favorites file (create it if it does not exist)
    #
    # helper function that moves the entry from the persistent history file to the excluded history file
    function excludeFromPersistentHistory {
	# check if the entry is included in the persistent history file (if yes, move to the excluded history file and re-sort the persistent history file)
	entryToExclude=`grep "$dirToAdd"';' "$p_hist_file"`;
	if [[ $? == 0 ]]; then
	    grep -v "$entryToExclude" "$p_hist_file" > "$temp_file";
	    # normally sorting would not be required (the persistent history file is already sorted and should remain so; it's just a safety precaution)
	    sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	    rm "$temp_file";
	    # history should be consolidated again
	    consolidateHistory;
	    # update excluded history file
	    echo $entryToExclude >> "$e_hist_file";
	else
	    # if file is not already included in persistent history, just add it to the excluded history file (with number of visits 0 as the directory hasn't been visited yet)
	    echo "$dirToAdd"';0' >> "$e_hist_file";
	fi
    }
    # helper function that sorts the favorites file by taking into account the name of each directory and not the path
    function sortFavoritesByBaseName {
	> "$temp_file";
	while read currentEntry;
	do
	    currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	    echo "$currentEntryConverted" >> "$temp_file";
	done < "$fav_file"
	sort -f "$temp_file" | cut -f 2 -d ':' > "$fav_file";
	rm "$temp_file";
    }
    #
    # finally add the directory to favorites and sort the entries by directory name
    if [[  -f "$fav_file" ]]; then
	grep -x "$dirToAdd" "$fav_file" > /dev/null;
	if [[ $? != 0 ]]; then
	    echo $dirToAdd >> "$fav_file";
	    sortFavoritesByBaseName;
	    echo "Directory $dirToAdd added to favorites.";
	    excludeFromPersistentHistory;
	    unset -f excludeFromPersistentHistory;
	    return 0;
	else
	    echo "Directory $dirToAdd already added to favorites.";
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
    else
	echo $dirToAdd >> "$fav_file";
	echo "Directory $dirToAdd added to favorites.";
	excludeFromPersistentHistory;
	unset -f excludeFromPersistentHistory;
	unset -f sortFavoritesByBaseName;
	return 0;
    fi
}
#
# ******************************************************************************************************************
#
# this function removes the entry from favorites and moves it back to persistent history
function removeFromFavorites {
    #
    # Step 1: check if the favorites file exists and is not empty
    if [[ ! -f "$fav_file" ]]; then
	echo "The favorites file $fav_file does not exist or has been deleted.";
	echo 'Please add a directory to favorites and then try again.';
	unset -f displayFavoritesFile;
	return 1;
    fi
    if [[ ! -s "$fav_file" ]]; then
	echo "File $fav_file is empty!";
	echo 'Nothing to remove';
	unset -f displayFavoritesFile;
	return 1;
    fi
    #
    # Step 2: display the file and prompt the user to choose the line to be deleted
    function displayFavoritesFile {
	clear;
	echo 'REMOVE DIRECTORY FROM FAVORITES';
	echo;
	cat -n "$fav_file";
	echo;
	echo 'Enter the number of the entry to be removed';
	echo 'Enter :q to quit';
	echo;
    }
    displayFavoritesFile;
    read -e dirNr;
    #
    # Step 3: check the input entered by user. If should be either:
    # - a number between 1 and and the number of entries contained in the file
    # - a character that triggers quitting the function
    tempVar=`wc -l "$fav_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    while [[ '1' == '1' ]];
    do
	if [[ $dirNr =~  $nonNegativeInteger     ]] &&
	   [[ $dirNr -ge 1                       ]] &&
	   [[ $dirNr -le $currentNumberOfEntries ]]; then
	    break;
	elif [[ $dirNr == ':q' ]]; then
	    clear;
	    echo 'No entry removed from favorites.';
	    unset -f displayFavoritesFile;
	    return 0;
	else
	    displayFavoritesFile;
	    echo 'Invalid option! Please try again.';
	    echo;
	    read -e dirNr;
	fi
    done
    #
    # Step 4: remove the entry from the excluded history file
    favDirToRemove=`sed "$dirNr"'q;d' "$fav_file"`;
    exclDirToRemove=`grep "$favDirToRemove"';' "$e_hist_file"`;
    visitsCount=`echo "$exclDirToRemove" | cut -f 2 -d ';'`;
    grep -v "$exclDirToRemove" "$e_hist_file" > "$temp_file";
    mv "$temp_file" "$e_hist_file";
    # Also move the entry back to the persistent history file if it has at least one visit
    if [[ $visitsCount -gt 0 ]]; then
	echo $exclDirToRemove >> "$p_hist_file";
	# Always sort the persistent history file when it is modified
	sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	mv "$temp_file" "$p_hist_file";
	# history should be consolidated again
	consolidateHistory;
    fi
    #
    # Step 5: delete the entry
    sed "$dirNr"'d' "$fav_file" > "$temp_file";
    mv "$temp_file" "$fav_file";
    clear;
    echo "Entry $favDirToRemove removed from the favorites menu.";
}
#
# ******************************************************************************************************************
#
# This function is used to enter navigation mode
# In this mode the user can repeatedly visit directories by only entering the name of each folder (absolute path, relative path - including wildcards)
# It is also possible to access other functions like history/favorites, goto previous directory etc.
function navigate {
    # helper function for executing a new shell command (either with new input or based on a previous command)
    function executeNewCommand {
	# memorize the command in a separate variable (otherwise the $command variable will be modified by eval in case the command is a script)
	prevCommand="$commandToExecute";
	echo "Command is being executed: $commandToExecute";
	echo '--------------------------';
	eval "$commandToExecute";
	commandStatus=$?;
	echo '--------------------------';
	echo -n 'Command ';
	if [[ 0 != $commandStatus ]]; then
	    commandResult='finished with errors';
	else
	    commandResult='finished successfully';
	fi
	echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
    }
    # helper function for executing previous shell command again
    function repeatPrevCommand {
	if [[ -z $prevCommand ]]; then
	    echo 'No shell command previously executed';
	else
	    echo "Command is being executed: $prevCommand";
	    echo '--------------------------';
	    eval "$prevCommand";
	    commandStatus=$?;
	    echo '--------------------------';
	    echo -n 'Command ';
	    if [[ 0 != $commandStatus ]]; then
		commandResult='finished with errors';
	    else
		commandResult='finished successfully';
	    fi
	    echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
	fi
    }
    # helper function used for displaying the content of the current directory
    function displayCurrentDirContent {
	# get number of items from current directory
	ls | tee "$aux_temp_file" | head -"$maxNrOfItems" > "$temp_file";
	tempOutput=`wc -l "$aux_temp_file"`;
	nrOfItems=`echo $tempOutput | cut -f 1 -d ' '`;
	> "$aux_temp_file";
	# limit the number of characters displayed for each item so current directory content is correctly displayed
	# (otherwise the content might be too much expanded)
	while read currentEntry;
	do
	    if [[ ${#currentEntry} -gt $maxNrOfChars ]]; then
		if [[ -d "$currentEntry" ]]; then
		    echo "${currentEntry:0:$maxNrOfChars}../" >> "$aux_temp_file";
		else
		    echo "${currentEntry:0:$maxNrOfChars}..." >> "$aux_temp_file";
		fi
	    else
		if [[ -d "$currentEntry" ]]; then
		    echo "$currentEntry"'/' >> "$aux_temp_file";
		else
		    echo "$currentEntry" >> "$aux_temp_file";
		fi
	    fi
	done < "$temp_file"
	rm "$temp_file";
	column "$aux_temp_file";
	if [[ $nrOfItems -gt $maxNrOfItems ]]; then
	    echo;
	    echo 'Number of items exceeds the displayed ones! Type :ls -p | less to display all directory items.';
	fi
	rm "$aux_temp_file";
    }
    # helper function used for displaying the help menu of the navigation mode
    function displayHelp {
	helpMenu='';
	helpMenu="$helpMenu"'echo "Navigation commands";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "For executing any shell command please enter : followed by the command string.";';
	helpMenu="$helpMenu"'echo "For example enter :ls -l to list the contents of the current directory in detail.";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Other useful navigation options: ";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo ":     -  repeat last successful shell command";';
	helpMenu="$helpMenu"'echo "::    -  enter a shell command based on previous command (only available in BASH 4)";';
	helpMenu="$helpMenu"'echo "<     -  enter history menu";';
	helpMenu="$helpMenu"'echo ":a    -  add current directory to favorites";';
	helpMenu="$helpMenu"'echo ":r    -  remove a directory from favorites";';
	helpMenu="$helpMenu"'echo ">     -  enter favorites menu";';
	helpMenu="$helpMenu"'echo ":p    -  go to the previously visited directory";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Press q to exit";';
	helpMenu="$helpMenu"'echo;';
	eval "$helpMenu" | less;
	echo 'You exited navigation help menu';
    }
    # helper function for handling general input (new commands or directories to navigate to)
    function handleGeneralInput {
	# A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
	if [[ ${dir_to_visit:0:1} == ':' ]]; then
	    commandToExecute=${dir_to_visit:1};
	    executeNewCommand;
	else
	    goToDir `echo "$dir_to_visit"`;
	fi
    }
    # helper function for executing a new command based on the string of the previously executed shell command
    function execCommandBasedOnPrevInput {
	if [[ -z "$prevCommand" ]]; then
	    echo 'No shell command previously executed. Enter a new command';
	else
	    echo 'Enter the required shell command based on the last executed command';
	fi
	echo '(press : and hit ENTER to quit):';
	read -e -i "$prevCommand" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    executeNewCommand;
	fi
    }
    # helper function used for displaying the "home screen" of the navigation function
    function displayGeneralNavigationOutput {
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Current directory:';
	echo `pwd`;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo "Directory content (hidden items are excluded):";
	echo;
	displayCurrentDirContent;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo -n "Last executed shell command";
	if [[ -z "$prevCommand" ]]; then
	    echo ':';
	    echo 'none';
	else
	    echo " ($commandResult):";
	    echo "$prevCommand";
	fi
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Enter the path of the directory you want to visit (press ENTER to return to the home dir).';
	echo 'Enter ? for the list of of available commands or :q to quit navigation mode.';
	echo;
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $dir_to_visit in
	'?')
	    displayHelp;
	    ;;
	':')
	    repeatPrevCommand;
	    ;;
	'::')
	    execCommandBasedOnPrevInput;
	    ;;
	'<')
	    goToMenu;
	    ;;
	'>')
	    goToMenu -f;
	    ;;
	':a')
	    addToFavorites;
	    ;;
	':r')
	    removeFromFavorites;
	    ;;
	':p')
	    goToPrevDir;
	    ;;
	':q')
	    return 0;
	    ;;
	*)
	    handleGeneralInput;
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	displayGeneralNavigationOutput;
	read -e dir_to_visit;
	clear;
	handleNavigationOption;
	if [[ $dir_to_visit == ':q' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f executeNewCommand;
	    unset -f repeatPrevCommand;
	    unset -f displayCurrentDirContent;
	    unset -f displayHelp;
	    unset -f handleGeneralInput;
	    unset -f execCommandBasedOnPrevInput;
	    unset -f displayGeneralNavigationOutput;
	    unset -f handleNavigationOption;
	    return 0;
	fi
    done
}
#
#
#
#
# *****************************************************************************************************************
#
# Disable all "private" functions so they cannot be accessed by user from CLI
# These functions are only helper functions that are used by the global functions in order to perform specific operations
# Direct access from user side might cause unexpected behavior
# In addition to this "global disable" (which is run only once when the file is loaded by shell) the private functions also need to be disabled each time they are used
# The exception is the consolidateHistory function which cannot be disabled as it is used by multiple global functions and is declared outside them
#
unset -f formatFileContent;
unset -f displayHistory;
unset -f displayFavorites;
unset -f handleMissingDirectory;
unset -f excludeFromPersistentHistory;
unset -f displayFavoritesFile;
unset -f sortFavoritesByBaseName;
unset -f executeNewCommand;
unset -f repeatPrevCommand;
unset -f displayCurrentDirContent;
unset -f displayHelp;
unset -f execCommandBasedOnPrevInput;
unset -f handleGeneralInput;
unset -f displayGeneralNavigationOutput;
unset -f handleNavigationOption;
#
#
#
#
# *****************************************************************************************************************
#
# Naming conventions used in this file:
# - variables containing path of working files (e.g. $p_hist_file): to be named using Python convention (underscore)
# - all other variables and all functions: to be named using lower camelCase convention
