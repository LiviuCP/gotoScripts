# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by choosing the entry number
# - adding directories to favorites menu and enabling jumping to one of these by just choosing the entry number
#
# GLOBAL VARIABLES
#
scriptDir=~; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
logDir=$scriptDir/.goToLogs; #in this directory the script stores the "log" files which contain the paths of the visited directories for each day
#
r_hist_file=$scriptDir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$scriptDir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
e_hist_file=$scriptDir/.excluded_history; #file containing the entries excluded from the persistent history file due to the fact that they had been added to favorites
c_r_hist_file=$scriptDir/.recent_command_history; #file containing the last commands executed by user in navigation mode (unsorted)
#
hist_file=$scriptDir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$scriptDir/.goto_favorites; #file containing the directories saved to favorites
format_file=$scriptDir/.goto_format; #file used for formatting output (either the content of the favorites file or the content of the consolidated history file)
c_hist_file=$scriptDir/.command_history; #file containing the last commands executed by user in navigation mode (sorted)
temp_file=$scriptDir/.temp; #temporary file used for various operations (to be removed each time the operation it is used in finishes)
aux_temp_file=$scriptDir/.aux_temp; #auxiliary temporary file (in case the first temp file is not enough)
#
rHistMaxRows=10; #maximum number of entries allowed in the recent history file
pHistMaxRows=15; #maximum number of entries allowed in the persistent history file
cHistMaxRows=25; #maximum number of entries allowed in the command history file
maxNrOfItems=50; #maximum number of files/dirs listed from current directory in navigation mode
maxNrOfChars=25; #maximum number of characters to be displayed for each item from current directory in navigation mode
minNrOfCmdChars=10; #minimum number of characters (including spaces) that a command should have to be included in command history
forwardUserInput=false; #variable used in navigation mode to determine if the user input received by a called function should be processed after function exits
editPrevCommand=false; #variable used for determinining if an entry from command history is fed to the user for editing so a new command is executed based on previous input
#
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a non-negative number
#
# GLOBAL FUNCTIONS
#
# This is a helper function shared by more of the below global functions (its purpose is to consolidate the persistent and recent history into a single file in a useful manner)
#
function consolidateHistory {
    # first sort the recent history file by name of each directory (not path) and add it to consolidated history
    > "$temp_file";
    > "$aux_temp_file";
    while read currentEntry;
    do
	currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	echo "$currentEntryConverted" >> "$temp_file";
    done < "$r_hist_file"
    sort -f "$temp_file" | cut -f 2 -d ':' > "$hist_file";
    rm "$temp_file";
    # do the same for persistent history and append it to consolidated history
    head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' > "$temp_file";
    while read currentEntry;
    do
	currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	echo "$currentEntryConverted" >> "$aux_temp_file";
    done < "$temp_file"
    sort -f "$aux_temp_file" | cut -f 2 -d ':' >> "$hist_file";
    rm "$temp_file";
    rm "$aux_temp_file";
}
#
# Same as previous function but this time for command history (in this stage it only sorts the recent command entries)
#
function consolidateCommandHistory {
    sort "$c_r_hist_file" > "$temp_file";
    mv "$temp_file" "$c_hist_file";
}
#
# This function is only run once (when this file is loaded) and prepares the environment for usage
#
function init {
    # create the required history and favorites files if they don't already exist
    touch "$r_hist_file";
    touch "$p_hist_file";
    touch "$e_hist_file";
    touch "$c_r_hist_file";
    touch "$fav_file";
    # ensure the recent history file has the maximum allowed number of entries
    head -"$rHistMaxRows" "$r_hist_file" > "$temp_file";
    mv "$temp_file" "$r_hist_file";
    # ensure the recent commands history file has the maximum allowed number of entries
    head -"$cHistMaxRows" "$c_r_hist_file" > "$temp_file";
    mv "$temp_file" "$c_r_hist_file";
    # consolidate history (in case the user just modified the number of entries allowed in recent and persistent history)
    consolidateHistory;
    # ensure the command history is sorted
    consolidateCommandHistory;
    # create log directory if not already existent
    if [[ ! -d "$logDir" ]]; then
	mkdir "$logDir";
    fi
    # ensure the log file for the current day exists; this file tracks all visited directories for the day and ensure they are not added to persistent history more than once
    w_log_file="$logDir"/`date +"%Y%m%d"`;
    touch "$w_log_file";
}
init;
unset -f init;
#
# This function closes all existing Finder windows and opens a new finder window with the directory mentioned in the first argument; any other arguments are ignored
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
function goToDir {
    # delays that are necessary for the error-free behavior of the function
    delayBeforeClose=0.2; #number of seconds of delay before using osascript to close the Finder window
    delayAfterReopen=0.3; #number of seconds of delay after re-opening the Finder window
    delayErrorReopen=1.5; #number of seconds of delay when an error occurs at Finder re-opening
    #
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory);
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    #
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    #
    # Step 3: close Finder if cd to the new dir had been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    else
	#enter a delay to prevent any unwanted behavior (in case the script has just been run and the Finder window re-opening process is not complete)
	sleep $delayBeforeClose;
	osascript -e 'quit app "Finder"';
    fi
    #
    # Step 4: re-open Finder in the new directory if previous close operation had been succesful;
    # Then check if re-open was successful:
    #     a) if not, terminate the script
    #     b) if yes, proceed to step 5
    if [[ $? != 0 ]]; then 
	echo 'An error occured when closing Finder.';
	echo "Reverting to previous directory $prevDir";
	cd - > /dev/null;
	echo 'Please try again.';
	#ensure the terminal stays in the foreground
	open –a terminal;
	return 1;
    else
	#open the desired folder in Finder (suppress error as it will be handled in the next step)
	open . 2> /dev/null;
	#delay further operations so user does not enter a new path before the directory is completely opened
	sleep $delayAfterReopen;
    fi
    #
    if [[ $? != 0 ]]; then
	#additional delay so the user doesn't attempt to re-run the command too soon (otherwise the Finder might crash)
	sleep $delayErrorReopen;
	#
	echo 'An error occured when opening the new directory in Finder.';
	echo "Reverting to previous directory $prevDir";
	cd - > /dev/null;
	echo 'Please try again.';
	#ensure the terminal stays in the foreground (in case Finder opens but an error is thrown nonetheless)
	open –a terminal;
	return 1;
    fi
    #
    # Step 5: if re-open was successful and cd was done to a different directory than the previous one, update the recent history file
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	open -a terminal;
	return 0;
    fi
    nrOfRows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
    matchedRow=`grep -xn "$currentDir" "$r_hist_file"`;
    #remove previous current directory path from history file if path is contained
    if [[ $? == 0 ]]; then
	matchedRowNr=`echo $matchedRow | cut -f 1 -d : `;
	sed "$matchedRowNr"'d' "$r_hist_file" > "$temp_file";
    #if number of rows is at maximum, remove a row to make room for the new entry
    elif [[ $nrOfRows -eq $rHistMaxRows ]]; then
	sed "$rHistMaxRows"'d' "$r_hist_file" > "$temp_file";
    #copy the history file to temporary file to maintain consistency with above cases
    else
	cp "$r_hist_file" "$temp_file";
    fi
    echo $currentDir > "$r_hist_file";
    cat "$temp_file" >> "$r_hist_file";
    rm "$temp_file";
    #
    # Step 6: check if the visited directory path is contained in the log file of the current day:
    # - if yes: consolidate history, no more actions required
    # - if not: go to next step
    grep -x "$currentDir" "$w_log_file" > /dev/null;
    if [[ $? == 0 ]]; then
	consolidateHistory;
	# no matter how the function works the terminal must remain the active window after the script finishes execution
	open -a terminal;
	return 0;
    else
	echo "$currentDir" >> "$w_log_file";
    fi
    # Step 7: check if the entry already exists in the persistent history file
    # - if yes: update the persistent history file, then sort it in reverse order by number of visits
    # - if not, check if included in excluded history file
    #   - if yes: update the excluded history file by incrementing the number of visits for the directory (no sorting required)
    #   - if not: add the entry to persistent history file and sort the file
    #
    # #use the ';' separator for the grep in order to avoid multiple matches
    pHistMatchedRow=`grep "$currentDir"';' "$p_hist_file"`;
    #
    if [[ $? == 0 ]]; then
	extractedPath=`echo $pHistMatchedRow | cut -f 1 -d ';'`;
	visitsCount=`echo $pHistMatchedRow | cut -f 2 -d ';'`;
	let "visitsCount=visitsCount+1";
	pHistReplacingRow="$extractedPath"';'"$visitsCount";
	grep -v "$pHistMatchedRow" "$p_hist_file" > "$temp_file";
	echo "$pHistReplacingRow" >> "$temp_file";
	sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
    else
	eHistMatchedRow=`grep "$currentDir"';' "$e_hist_file"`;
	if [[ $? == 0 ]]; then
	    extractedPath=`echo $eHistMatchedRow | cut -f 1 -d ';'`;
	    visitsCount=`echo $eHistMatchedRow | cut -f 2 -d ';'`;
	    let "visitsCount=visitsCount+1";
	    eHistReplacingRow="$extractedPath"';'"$visitsCount";
	    grep -v "$eHistMatchedRow" "$e_hist_file" > "$temp_file";
	    echo "$eHistReplacingRow" >> "$temp_file";
	    mv "$temp_file" "$e_hist_file";
	else
	    echo "$currentDir"';1' >> "$p_hist_file";
	    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	    mv "$temp_file" "$p_hist_file";
	fi
    fi
    #
    # consolidate the recent and persistent history into a single file so the user can see both of them in the history menu
    consolidateHistory;
    # no matter how the function works the terminal must remain the active window after the script finishes execution
    open -a terminal;
}
#
# ******************************************************************************************************************
#
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Helper functions for display
    #
    # formats the content of the consolidated history file or the favorites file; output is written into a file that is used by one of the display functions listed below
    function formatFileContent {
	input_file=$1;
	> "$format_file";
	while read currentEntry;
	do
	    currentEntryFormatted=`basename "$currentEntry"`':     '"$currentEntry";
	    echo "$currentEntryFormatted" >> "$format_file";
	done < "$input_file"
	column -t -s ':' "$format_file" > "$temp_file";
	mv "$temp_file" "$format_file";
    }
    #displays the consolidated history menu in a convenient manner for the user
    function displayHistory {
	tempVar1=`wc -l "$r_hist_file"`;
	tempVar2=`wc -l "$hist_file"`;
	rHistEntries=`echo $tempVar1 | cut -f 1 -d ' '`;
	histEntries=`echo $tempVar2 | cut -f 1 -d ' '`;
	let pHistEntries=histEntries-rHistEntries;
	formatFileContent "$hist_file";
	clear;
	echo 'NAVIGATION HISTORY';
	echo;
	echo '-- RECENTLY VISITED DIRECTORIES --';
	echo;
	cat -n "$format_file" | head -"$rHistEntries";
	echo;
	echo '--   MOST VISITED DIRECTORIES   --';
	echo;
	cat -n "$format_file" | tail -"$pHistEntries";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	echo 'Enter ! to quit.';
	echo;
    }
    #displays the favorites menu in a different (tailor-made) manner from the history menu
    function displayFavorites {
	formatFileContent "$fav_file";
	clear;
	echo 'FAVORITE DIRECTORIES';
	echo;
	cat -n "$format_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	echo 'Enter ! to quit.';
	echo;
    }
    # handles the case when the directory chosen for visiting does not exist
    function handleMissingDirectory {
	# working log file for the current day also needs update (if existing and if the entry is present)
	w_log_file="$logDir"/`date +"%Y%m%d"`;
	clear;
	echo "Invalid path $dirPath";
	echo 'The directory might have been moved or deleted.';
	echo;
	echo 'Please choose the required action: ';
	echo '!r to remove the directory from the menus';
	echo '!m to map to an existing directory';
	echo '! to quit';
	echo;
	read -e userChoice;
	# user chooses to remove the entry from menus (consolidated history and/or favorites)
	if [[ $userChoice == '!r' ]]; then
	    # ensure the entry gets removed from the working log file (if the file had been created in the current day)
	    if [[ -f "$w_log_file" ]]; then
		grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		mv "$temp_file" "$w_log_file";
	    fi
	    # ensure the entry is removed from recent history (if there)
	    grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # ensure the entry is removed from persistent history (if there)
	    grep -v "$dirPath"';' "$p_hist_file" > "$temp_file";
	    sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	    rm "$temp_file";
	    # ensure the entry is removed from favorites file (if there)
	    grep -v "$dirPath"';' "$e_hist_file" > "$temp_file";
	    mv "$temp_file" "$e_hist_file";
	    grep -xv "$dirPath" "$fav_file" > "$temp_file";
	    mv "$temp_file" "$fav_file";
	    # history should be consolidated again
	    consolidateHistory;
	    # confirm removal has been successfully performed
	    echo;
	    echo "Entry $dirPath has been removed from the menus.";
	# user chooses to replace the directory entry with another (existing) path
	elif [[ $userChoice == '!m' ]]; then
	    clear;
	    echo 'Enter the name of the replacing directory: ';
	    read -e replacingDir;
	    # the mapping directory should exist and be a valid directory
	    if [[ ! -d "$replacingDir" ]]; then
		echo "Directory $replacingDir does not exist or has been deleted.";
		echo "Cannot map the missing directory $dirPath.";
		return 1;
	    fi
	    # ensure the entry gets removed from the working log file (if the file had been created in the current day)
	    if [[ -f "$w_log_file" ]]; then
		grep -xv "$dirPath" "$w_log_file" > "$temp_file";
		mv "$temp_file" "$w_log_file";
	    fi
	    # ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
	    cd "$replacingDir";
	    replacingDir=`pwd`;
	    cd - > /dev/null;
	    # identify the file where the path of the directory to be replaced lives
	    grep "$dirPath"';' "$e_hist_file" > /dev/null;
	    if [[ $? == 0 ]]; then
		replaced_dir_file="$e_hist_file";
	    else
		replaced_dir_file="$p_hist_file";
	    fi
	    # check if the replacing dir is part of consolidated history, favorites file or none of them (not yet visited or added to favorites)
	    visits_file=''; # the file where the number of visits of the replacing directory will be looked for (no file if not yet visited or added to favorites)
	    foundEntry=`grep "$replacingDir"';' "$p_hist_file"`;
	    if [[ $? == 0 ]]; then
		visits_file="$p_hist_file";
	    else
		foundEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		if [[ $? == 0 ]]; then
		    visits_file="$e_hist_file";
		fi
	    fi
	    # get number of times the replacing directory has been visited (-1 if not visited/not added to favorites)
	    if [[ "$visits_file" == "$p_hist_file" ]]; then
		replacingDirEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    elif [[ "$visits_file" == "$e_hist_file" ]]; then
		replacingDirEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
	    else
		replacingDirVisits='-1';
	    fi
	    # remove the entry from recent history (if there)
	    grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
	    mv "$temp_file" "$r_hist_file";
	    # do the actual mapping operation
	    replacedDirMatchedRow=`grep "$dirPath"';' "$replaced_dir_file"`;
	    replacedDirVisits=`echo $replacedDirMatchedRow | cut -f 2 -d ';'`;
	    # - case 1: the replacing directory is not contained in the files (not yet visited/not yet added to favorites) - just do a path replacement
	    if [[ $replacingDirVisits == '-1' ]]; then
		replacedDirReplacingRow="$replacingDir"';'"$replacedDirVisits";
		grep -v "$replacedDirMatchedRow" "$replaced_dir_file" > "$temp_file";
		echo "$replacedDirReplacingRow" >> "$temp_file";
		mv "$temp_file" "$replaced_dir_file";
		# if missing dir had been in the persistent history file: re-sort file
		if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
		    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		    mv "$temp_file" "$p_hist_file";
		# if missing dir had been in the excluded history file: re-create favorites file after update
		else
		    cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		fi
	    # - case 2: the replacing directory is contained either in the persistent history file or in the favorites file
	    else
		# if the number of visits of the dir to be replaced exceeds the one of the replacing dir, then update the number of visits of the replacing dir to the higher figure
		if [[ $replacingDirVisits -lt $replacedDirVisits ]]; then
		    replacingDirPath=`echo $replacingDirEntry | cut -f 1 -d ';'`;
		    replacingDirReplacingRow="$replacingDirPath"';'"$replacedDirVisits";
		    grep -v "$replacingDirEntry" "$visits_file" > "$temp_file";
		    echo "$replacingDirReplacingRow" >> "$temp_file";
		    mv "$temp_file" "$visits_file";
		fi
		# remove the replaced directory from its file (either persistent history or excluded history file)
		grep -v "$dirPath"';' "$replaced_dir_file" > "$temp_file";
		mv "$temp_file" "$replaced_dir_file";
		# if missing dir had been in the persistent history file: re-sort file
		if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
		    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		    mv "$temp_file" "$p_hist_file";
		# if missing dir had been in the excluded history file: re-create favorites file after update
		else
		    cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		fi
	    fi
	    # history should be consolidated again
	    consolidateHistory;
	    # confirm mapping has been successfully performed
	    echo "Missing directory: $dirPath";
	    echo "Replacing directory: $replacingDir";
	    echo 'Mapping performed successfully.';
	elif [[ $userChoice == '!' ]]; then
	    clear;
	    echo "You exited the $menuType menu.";
	else
	    # handle the input as "normal" navigation input
	    navigationInput="$userChoice";
	    forwardUserInput=true;
	fi
    }
    # unsets all helper functions so they are not accessible by user from CLI
    # should be called before the main function returns, otherwise the helpers might become inaccessible earlier than required
    # the unsetHelpers function should be itself unset (right after it runs)
    function unsetHelpers {
	unset -f formatFileContent;
	unset -f displayHistory;
	unset -f displayFavorites;
	unset -f handleMissingDirectory;
    }
    #
    # Step 0: choose the file to be used for navigating, check if it is empty, (if not) display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
    if [[ "$1" == '-f' ]]; then
	input_file="$fav_file";
	display='displayFavorites';
	menuType='favorites';
    elif [[ "$1" == '-h' ]]; then
	input_file="$hist_file";
	display='displayHistory';
	menuType='history';
    else
	echo 'Invalid first argument of the goToMenu function.';
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    #
    if [[ ! -s "$input_file" ]]; then
	echo "There are no entries in the $menuType menu.";
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    eval "$display";
    if [[ -z "$2" ]]; then
	read -e dirNr;
    else
	dirNr=$2;
    fi
    #
    # Step 1: handle the user input
    tempVar=`wc -l "$input_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    # 1a: user entered the number of an entry from the history/favorites file
    if [[ $dirNr =~  $nonNegativeInteger     ]] &&
       [[ $dirNr -ge 1                       ]] &&
       [[ $dirNr -le $currentNumberOfEntries ]]; then
	# read the line from the input file
	dirPath=`sed "$dirNr"'q;d' "$input_file"`;
	# if the line of the input file contains a valid directory path, then visit the directory
	if [[ ! -d "$dirPath" ]]; then
	    handleMissingDirectory;
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 1;
	fi
	goToDir "$dirPath";
    # 1b: user chose to quit the function
    elif [[ $dirNr == '!' ]]; then
	clear;
	echo "You exited the $menuType menu.";
    # 1c: any other input to be passed further to the navigate function (if goToMenu had been called from navigation mode)
    else
	navigationInput="$dirNr";
	forwardUserInput=true;
	return 0;
    fi
    #
    unsetHelpers 2> /dev/null;
    unset -f unsetHelpers;
}
#
# ******************************************************************************************************************
#
# used for returning to the previously visited directory without needing to access the history or favorites menus
function goToPrevDir {
    if [[ $prevDir == '' ]]; then
	echo 'Cannot jump to previous directory.';
	echo 'No directory visited in the current session.';
	return 1;
    fi
    goToDir "$prevDir";
}
#
# ******************************************************************************************************************
#
# used for adding a directory (either the current one or another) to favorites
function addToFavorites {
    #
    # Step 1: check if the user entered an argument or not
    # - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
    # - if no argument was entered, the current directory will be added to favorites
    if [[ ! -z "$1" ]]; then
	if [[ ! -d "$1" ]]; then
	    echo "Directory $1 does not exist or has been deleted.";
	    echo 'Cannot add to favorites.';
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
	cd "$1";
	dirToAdd=`pwd`;
	cd - > /dev/null;
    else
	dirToAdd=`pwd`;
    fi
    #
    # Step 2: append the path to the favorites file (create it if it does not exist)
    #
    # helper function that moves the entry from the persistent history file to the excluded history file
    function excludeFromPersistentHistory {
	# check if the entry is included in the persistent history file (if yes, move to the excluded history file and re-sort the persistent history file)
	entryToExclude=`grep "$dirToAdd"';' "$p_hist_file"`;
	if [[ $? == 0 ]]; then
	    grep -v "$entryToExclude" "$p_hist_file" > "$temp_file";
	    # normally sorting would not be required (the persistent history file is already sorted and should remain so; it's just a safety precaution)
	    sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	    rm "$temp_file";
	    # history should be consolidated again
	    consolidateHistory;
	    # update excluded history file
	    echo $entryToExclude >> "$e_hist_file";
	else
	    # if file is not already included in persistent history, just add it to the excluded history file (with number of visits 0 as the directory hasn't been visited yet)
	    echo "$dirToAdd"';0' >> "$e_hist_file";
	fi
    }
    # helper function that sorts the favorites file by taking into account the name of each directory and not the path
    function sortFavoritesByBaseName {
	> "$temp_file";
	while read currentEntry;
	do
	    currentEntryConverted=`basename "$currentEntry"`':'"$currentEntry";
	    echo "$currentEntryConverted" >> "$temp_file";
	done < "$fav_file"
	sort -f "$temp_file" | cut -f 2 -d ':' > "$fav_file";
	rm "$temp_file";
    }
    #
    # finally add the directory to favorites and sort the entries by directory name
    if [[  -f "$fav_file" ]]; then
	grep -x "$dirToAdd" "$fav_file" > /dev/null;
	if [[ $? != 0 ]]; then
	    echo $dirToAdd >> "$fav_file";
	    sortFavoritesByBaseName;
	    echo "Directory $dirToAdd added to favorites.";
	    excludeFromPersistentHistory;
	    unset -f excludeFromPersistentHistory;
	    return 0;
	else
	    echo "Directory $dirToAdd already added to favorites.";
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
    else
	echo $dirToAdd >> "$fav_file";
	echo "Directory $dirToAdd added to favorites.";
	excludeFromPersistentHistory;
	unset -f excludeFromPersistentHistory;
	unset -f sortFavoritesByBaseName;
	return 0;
    fi
}
#
# ******************************************************************************************************************
#
# this function removes the entry from favorites and moves it back to persistent history
function removeFromFavorites {
    #
    # Step 1: check if the favorites file exists and is not empty
    if [[ ! -f "$fav_file" ]]; then
	echo "The favorites file $fav_file does not exist or has been deleted.";
	echo 'Please add a directory to favorites and then try again.';
	unset -f displayFavoritesFile;
	return 1;
    fi
    if [[ ! -s "$fav_file" ]]; then
	echo "File $fav_file is empty!";
	echo 'Nothing to remove';
	unset -f displayFavoritesFile;
	return 1;
    fi
    #
    # Step 2: display the file and prompt the user to choose the line to be deleted
    function displayFavoritesFile {
	clear;
	echo 'REMOVE DIRECTORY FROM FAVORITES';
	echo;
	cat -n "$fav_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter the number of the entry to be removed';
	echo 'Enter ! to quit';
	echo;
    }
    displayFavoritesFile;
    read -e dirNr;
    #
    # Step 3: check the input entered by user and perform the required actions
    tempVar=`wc -l "$fav_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    if [[ $dirNr =~  $nonNegativeInteger     ]] &&
       [[ $dirNr -ge 1                       ]] &&
       [[ $dirNr -le $currentNumberOfEntries ]]; then
	favDirToRemove=`sed "$dirNr"'q;d' "$fav_file"`;
	exclDirToRemove=`grep "$favDirToRemove"';' "$e_hist_file"`;
	visitsCount=`echo "$exclDirToRemove" | cut -f 2 -d ';'`;
	grep -v "$exclDirToRemove" "$e_hist_file" > "$temp_file";
	mv "$temp_file" "$e_hist_file";
	# Also move the entry back to the persistent history file if it has at least one visit
	if [[ $visitsCount -gt 0 ]]; then
	    echo $exclDirToRemove >> "$p_hist_file";
	    # Always sort the persistent history file when it is modified
	    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	    mv "$temp_file" "$p_hist_file";
	    # history should be consolidated again
	    consolidateHistory;
	fi
	# actual remove operation
	sed "$dirNr"'d' "$fav_file" > "$temp_file";
	mv "$temp_file" "$fav_file";
	clear;
	echo "Entry $favDirToRemove removed from the favorites menu.";
    elif [[ $dirNr == '!' ]]; then
	clear;
	echo 'No entry removed from favorites.';
	unset -f displayFavoritesFile;
    else
	# handle the input as "normal" navigation input
	navigationInput="$dirNr";
	forwardUserInput=true;
    fi
}
#
# ******************************************************************************************************************
#
# This function is used to enter navigation mode
# In this mode the user can repeatedly visit directories by only entering the name of each folder (absolute path, relative path - including wildcards)
# It is also possible to access other functions like history/favorites, goto previous directory etc.
function navigate {
    # accesses the menu with the most recent executed commands, user can choose one entry to execute that command again
    function goToCommandMenu {
	if [[ ! -s "$c_hist_file" ]]; then
	    echo "There are no entries in the command history menu.";
	    return 1;
	fi
	clear;
	echo 'COMMAND HISTORY';
	echo;
	if [[ $editPrevCommand == false ]]; then
	    echo '-- EXECUTE COMMAND --';
	else
	    echo '-- EDIT COMMAND --';
	fi
	echo;
	cat -n "$c_hist_file";
	echo;
	echo 'Current directory: '`pwd`;
	echo;
	echo 'Enter command number.';
	echo 'Enter ! to quit';
	echo;
	read -e cmdNr;
	# check the input entered by user and perform the required actions
	tempVar=`wc -l "$c_hist_file"`;
	currentNumberOfCmdEntries=`echo $tempVar | cut -f 1 -d ' '`;
	if [[ $cmdNr =~  $nonNegativeInteger     ]] &&
	   [[ $cmdNr -ge 1                       ]] &&
	   [[ $cmdNr -le $currentNumberOfCmdEntries ]]; then
	    clear;
	    commandHistoryEntry=`sed "$cmdNr"'q;d' "$c_hist_file"`;
	    if [[ $editPrevCommand == false ]]; then
		# execute the actual command from command history menu
		commandToExecute="$commandHistoryEntry";
		executeNewCommand;
	    else
		# edit the chosen command prior to executing
		editAndExecCmdFromHistory;
	    fi
	elif [[ $cmdNr == '!' ]]; then
	    clear;
	    echo 'No command chosen.';
	else
	    # handle the input as "normal" navigation input
	    navigationInput="$cmdNr";
	    forwardUserInput=true;
	fi
    }
    # updates the file with most recently executed commands and sorts it
    function updateCommandHistory {
	nrOfCmdRows=`wc -l "$c_r_hist_file" | awk '{print $1;}'`;
	matchedCmdRow=`grep -Fxn "$prevCommand" "$c_r_hist_file"`;
	#remove previous command from history file if already contained
	if [[ $? == 0 ]]; then
	    matchedCmdRowNr=`echo $matchedCmdRow | cut -f 1 -d : `;
	    sed "$matchedCmdRowNr"'d' "$c_r_hist_file" > "$temp_file";
	#if number of rows is at maximum, remove a row to make room for the new entry
	elif [[ $nrOfCmdRows -eq $cHistMaxRows ]]; then
	    sed "$cHistMaxRows"'d' "$c_r_hist_file" > "$temp_file";
	#copy the history file to temporary file to maintain consistency with above cases
	else
	    cp "$c_r_hist_file" "$temp_file";
	fi
	echo "$prevCommand" > "$c_r_hist_file";
	cat "$temp_file" >> "$c_r_hist_file";
	rm "$temp_file";
	#finally sort the file so user can spot the commands easier
	consolidateCommandHistory;
    }
    # erases the command history (this operation is done independently of the one that erases navigation history)
    function clearCommandHistory {
	> "$c_r_hist_file";
	> "$c_hist_file";
	echo 'Content of command history menu has been erased.';
    }
    # helper function for executing a new shell command (either with new input or based on a previous command)
    function executeNewCommand {
	# memorize the command in a separate variable (otherwise the $command variable will be modified by eval in case the command is a script)
	prevCommand="$commandToExecute";
	if [[ ${#commandToExecute} -ge $minNrOfCmdChars ]]; then
	    updateCommandHistory;
	fi
	echo "Command is being executed: $commandToExecute";
	echo '--------------------------';
	eval "$commandToExecute";
	commandStatus=$?;
	echo '--------------------------';
	echo -n 'Command ';
	if [[ 0 != $commandStatus ]]; then
	    commandResult='finished with errors';
	else
	    commandResult='finished successfully';
	fi
	echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
    }
    # helper function for executing previous shell command again
    function repeatPrevCommand {
	if [[ -z $prevCommand ]]; then
	    echo 'No shell command previously executed';
	else
	    echo "Command is being executed: $prevCommand";
	    echo '--------------------------';
	    eval "$prevCommand";
	    commandStatus=$?;
	    echo '--------------------------';
	    echo -n 'Command ';
	    if [[ 0 != $commandStatus ]]; then
		commandResult='finished with errors';
	    else
		commandResult='finished successfully';
	    fi
	    echo "$commandResult! Scroll up to check output (if any) if it exceeds the screen.";
	fi
    }
    # helper function that feeds a previously executed command (from command history) to user for editing prior to having it executed
    function editAndExecCmdFromHistory {
	echo 'Please edit the below command and hit ENTER to execute';
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$commandHistoryEntry" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    executeNewCommand;
	fi
    }
    # helper function used for displaying the content of the current directory
    function displayCurrentDirContent {
	# get number of items from current directory
	ls | tee "$aux_temp_file" | head -"$maxNrOfItems" > "$temp_file";
	tempOutput=`wc -l "$aux_temp_file"`;
	nrOfItems=`echo $tempOutput | cut -f 1 -d ' '`;
	> "$aux_temp_file";
	# limit the number of characters displayed for each item so current directory content is correctly displayed
	# (otherwise the content might be too much expanded)
	while read currentEntry;
	do
	    if [[ ${#currentEntry} -gt $maxNrOfChars ]]; then
		if [[ -d "$currentEntry" ]]; then
		    echo "${currentEntry:0:$maxNrOfChars}../" >> "$aux_temp_file";
		else
		    echo "${currentEntry:0:$maxNrOfChars}..." >> "$aux_temp_file";
		fi
	    else
		if [[ -d "$currentEntry" ]]; then
		    echo "$currentEntry"'/' >> "$aux_temp_file";
		else
		    echo "$currentEntry" >> "$aux_temp_file";
		fi
	    fi
	done < "$temp_file"
	rm "$temp_file";
	column "$aux_temp_file";
	if [[ $nrOfItems -gt $maxNrOfItems ]]; then
	    echo;
	    echo 'Number of items exceeds the displayed ones! Type :ls -p | less to display all directory items.';
	fi
	rm "$aux_temp_file";
    }
    # helper function used for displaying the help menu of the navigation mode
    function displayHelp {
	helpMenu='';
	helpMenu="$helpMenu"'echo "Navigation functions";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "For executing any shell command please enter : followed by the command string.";';
	helpMenu="$helpMenu"'echo "For example enter :ls -l to list the contents of the current directory in detail.";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Other useful navigation options: ";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo ":-    -  repeat last executed shell command (if any)";';
	helpMenu="$helpMenu"'echo ":     -  enter a shell command based on previous command (only available in BASH 4)";';
	helpMenu="$helpMenu"'echo ":<    -  enter command history menu";';
	helpMenu="$helpMenu"'echo "::    -  enter command history menu to edit a previous command (only available in BASH 4)";';
	helpMenu="$helpMenu"'echo ":<>   -  clear command history";';
	helpMenu="$helpMenu"'echo "<     -  enter history menu";';
	helpMenu="$helpMenu"'echo ">     -  enter favorites menu";';
	helpMenu="$helpMenu"'echo ",     -  go to the previously visited directory";';
	helpMenu="$helpMenu"'echo ">>    -  add current directory to favorites";';
	helpMenu="$helpMenu"'echo "!>    -  remove a directory from favorites";';
	helpMenu="$helpMenu"'echo "!<>   -  clear navigation history";';
	helpMenu="$helpMenu"'echo;';
	helpMenu="$helpMenu"'echo "Press q to exit";';
	helpMenu="$helpMenu"'echo;';
	eval "$helpMenu" | less;
	echo 'You exited navigation help menu';
    }
    # helper function for handling general input (new commands or directories to navigate to)
    function handleGeneralInput {
	# A string starting with ':' will be treated as a command (alternative way of entering new commands from navigation mode)
	if [[ ${navigationInput:0:1} == ':' ]]; then
	    commandToExecute=${navigationInput:1};
	    executeNewCommand;
	else
	    goToDir `echo "$navigationInput"`;
	fi
    }
    # helper function for executing a new command based on the string of the previously executed shell command
    function execCommandBasedOnPrevInput {
	if [[ -z "$prevCommand" ]]; then
	    echo 'No shell command previously executed. Enter a new command';
	else
	    echo 'Please edit the below command and hit ENTER to execute';
	fi
	echo '(press : and hit ENTER to quit):';
	echo;
	read -e -i "$prevCommand" commandToExecute;
	if [[ $? != 0 ]]; then
	    clear;
	    echo 'This command is only available in BASH 4';
	    echo 'Please install the appropriate BASH version';
	elif [[ -z "$commandToExecute" ]] || [[ "$commandToExecute" =~ :$ ]]; then
	    clear;
	    echo 'Command aborted. You returned to navigation menu';
	else
	    clear;
	    executeNewCommand;
	fi
    }
    # helper function used for displaying the "home screen" of the navigation function
    function displayGeneralNavigationOutput {
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Current directory:';
	echo `pwd`;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo "Directory content (hidden items are excluded):";
	echo;
	displayCurrentDirContent;
	echo;
	echo '----------------------------------------------------------------------------------------------------';
	echo;
	echo -n "Last executed shell command";
	if [[ -z "$prevCommand" ]]; then
	    echo ':';
	    echo 'none';
	else
	    echo " ($commandResult):";
	    echo "$prevCommand";
	fi
	echo;
	echo '****************************************************************************************************';
	echo;
	echo 'Enter the path of the directory you want to visit (press ENTER to return to the home dir).';
	echo 'Enter ? for the list of of available commands or ! to quit navigation mode.';
	echo;
    }
    # helper function for erasing the navigation history
    function clearHistory {
	> "$hist_file";
	> "$r_hist_file";
	> "$p_hist_file";
	> "$e_hist_file";
	# the working log file also needs to be reset to ensure consistency with the history content
	w_log_file="$logDir"/`date +"%Y%m%d"`;
	if [[ -f "$w_log_file" ]]; then
	    > "$w_log_file";
	fi
	# favorites file should be kept so excluded history should be re-created (0 visits per entry)
	while read currentEntry;
	do
	    echo "$currentEntry"';0' >> "$e_hist_file";
	done < "$fav_file"
	echo 'Content of navigation history menu has been erased.';
    }
    # helper function that handles all possible options entered by user in navigation mode
    function handleNavigationOption {
	case $navigationInput in
	'?')
	    displayHelp;
	    ;;
	':-')
	    repeatPrevCommand;
	    ;;
	':')
	    execCommandBasedOnPrevInput;
	    ;;
	':<')
	    editPrevCommand=false;
	    goToCommandMenu;
	    ;;
	'::')
	    editPrevCommand=true;
	    goToCommandMenu;
	    ;;
	':<>')
	    clearCommandHistory;
	    ;;
	'<')
	    # it is necessary to put an argument for accessing history even if not used (as $2 will be checked when accessing the menu entry without entering read mode)
	    goToMenu -h;
	    ;;
	'>')
	    goToMenu -f;
	    ;;
	',')
	    goToPrevDir;
	    ;;
	'>>')
	    addToFavorites;
	    ;;
	'!>')
	    removeFromFavorites;
	    ;;
	'!<>')
	    clearHistory;
	    ;;
	'!')
	    return 0;
	    ;;
	*)
	    handleGeneralInput;
	    ;;
	esac
    }
    # stores last executed shell command (if any) and its result
    prevCommand='';
    commandResult='';
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	displayGeneralNavigationOutput;
	read -e navigationInput;
	# stay in this loop as long as the function called by choosing a navigation option forwards user input back to the navigate function
	while [[ '1' == '1' ]]; do
	    clear;
	    handleNavigationOption;
	    if [[ $forwardUserInput == true ]]; then
		forwardUserInput=false;
	    else
		break;
	    fi
	done
	if [[ $navigationInput == '!' ]]; then
	    echo 'You exited navigation mode.';
	    unset -f goToCommandMenu;
	    unset -f updateCommandHistory;
	    unset -f clearCommandHistory;
	    unset -f executeNewCommand;
	    unset -f repeatPrevCommand;
	    unset -f editAndExecCmdFromHistory;
	    unset -f displayCurrentDirContent;
	    unset -f displayHelp;
	    unset -f handleGeneralInput;
	    unset -f execCommandBasedOnPrevInput;
	    unset -f displayGeneralNavigationOutput;
	    unset -f handleNavigationOption;
	    unset -f clearHistory;
	    return 0;
	fi
    done
}
#
#
#
#
# *****************************************************************************************************************
#
# Disable all "private" functions so they cannot be accessed by user from CLI
# These functions are only helper functions that are used by the global functions in order to perform specific operations
# Direct access from user side might cause unexpected behavior
# In addition to this "global disable" (which is run only once when the file is loaded by shell) the private functions also need to be disabled each time they are used
# The exception is the consolidateHistory function which cannot be disabled as it is used by multiple global functions and is declared outside them
#
unset -f formatFileContent;
unset -f displayHistory;
unset -f displayFavorites;
unset -f handleMissingDirectory;
unset -f excludeFromPersistentHistory;
unset -f displayFavoritesFile;
unset -f sortFavoritesByBaseName;
unset -f goToCommandMenu;
unset -f updateCommandHistory;
unset -f clearCommandHistory;
unset -f executeNewCommand;
unset -f repeatPrevCommand;
unset -f editAndExecCmdFromHistory;
unset -f displayCurrentDirContent;
unset -f displayHelp;
unset -f execCommandBasedOnPrevInput;
unset -f handleGeneralInput;
unset -f displayGeneralNavigationOutput;
unset -f handleNavigationOption;
unset -f clearHistory;
#
#
#
#
# *****************************************************************************************************************
#
# Naming conventions used in this file:
# - variables containing path of working files (e.g. $p_hist_file): to be named using Python convention (underscore)
# - all other variables and all functions: to be named using lower camelCase convention
