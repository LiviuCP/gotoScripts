# This file contains functions used for:
# - navigating between folders
# - tracking history of navigated folders and enabling the user to jump directly to one of these directories by choosing the entry number
# - adding directories to favorites menu and enabling jumping to one of these by just choosing the entry number
#
# GLOBAL VARIABLES
#
scriptDir=`pwd`; #get script directory in order to build the paths of the supporting files
prevDir=''; #this variable is used both by the goto function and the function that jumps to previous directory
#
r_hist_file=$scriptDir/.recent_history; #file containing a list of the most recently visited directories
p_hist_file=$scriptDir/.persistent_history; #file containing each visited directory and the number of visits (used for determining the most visited directories, which will be copied in the consolidated history file)
e_hist_file=$scriptDir/.excluded_history; #file containing the entries excluded from the persistent history file due to the fact that they had been added to favorites
#
hist_file=$scriptDir/.goto_history; #file containing the consolidated directory access history (most recently and most frequently visited dirs)
fav_file=$scriptDir/.goto_favorites; #file containing the directories saved to favorites
format_file=$scriptDir/.goto_format; #file used for formatting output (either the content of the favorites file or the content of the consolidated history file)
temp_file=$scriptDir/.temp; #temporary file used for various operations (to be removed each time the operation it is used in finishes)
#
rHistMaxRows=5; #maximum number of entries allowed in the recent history file
pHistMaxRows=20; #maximum number of entries allowed in the persistent history file
#
nonNegativeInteger='^[0-9]+$'; #regex used to test if the input is a non-negative number
#
# GLOBAL FUNCTIONS
#
# This function closes all existing Finder windows and opens a new finder window with the directory mentioned in the first argument; any other arguments are ignored
# The argument can be a relative or an absolute path
# The function returns value 0 for successful execution and 1 in any other situation
#
function goToDir {
    # delays that are necessary for the error-free behavior of the function
    delayBeforeClose=0.2; #number of seconds of delay before using osascript to close the Finder window
    delayAfterReopen=0.3; #number of seconds of delay after re-opening the Finder window
    delayErrorReopen=1.5; #number of seconds of delay when an error occurs at Finder re-opening
    #
    # Step 1: if an argument was entered check that the argument is valid (entered path exists and is a directory); check if the history files exist
    if [[ ! -z $1 ]] && [[ ! -d $1 ]]; then
	if [[ -e $1 ]]; then
	    echo "$1 is not a directory.";
	    return 1;
	fi
	echo "Invalid directory $1";
	echo 'Either is the name invalid (please check spelling) or the directory has been deleted.';
	return 1;  
    fi
    # create the history files if they don't already exist
    if [[ ! -f "$r_hist_file" ]]; then
	> "$r_hist_file";
    fi
    if [[ ! -f "$p_hist_file" ]]; then
	> "$p_hist_file";
    fi
    if [[ ! -f "$e_hist_file" ]]; then
	> "$e_hist_file";
    fi
    #
    # Step 2: memorize current directory and cd to the new directory (if no argument had been entered, cd to the user home directory)
    prevDir=`pwd`; #current directory will become previous current directory (needs to be stored for being added to the history file)
    if [[ -z $1 ]]; then
	cd ~ ;
    else
	cd "$1";
    fi
    #
    # Step 3: close Finder if cd to the new dir had been successful
    if [[ $? != 0 ]]; then 
	echo 'Cannot change directory, the cd command returned an error.';
	echo 'Please try again.';
	return 1;  
    else
	#enter a delay to prevent any unwanted behavior (in case the script has just been run and the Finder window re-opening process is not complete)
	sleep $delayBeforeClose;
	osascript -e 'quit app "Finder"';
    fi
    #
    # Step 4: re-open Finder in the new directory if previous close operation had been succesful;
    # Then check if re-open was successful:
    #     a) if not, terminate the script
    #     b) if yes, proceed to step 5
    if [[ $? != 0 ]]; then 
	echo 'An error occured when closing Finder.';
	echo "Reverting to previous directory $prevDir";
	cd - > /dev/null;
	echo 'Please try again.';
	#ensure the terminal stays in the foreground
	open –a terminal;
	return 1;
    else
	#open the desired folder in Finder (suppress error as it will be handled in the next step)
	open . 2> /dev/null;
	#delay further operations so user does not enter a new path before the directory is completely opened
	sleep $delayAfterReopen;
    fi
    #
    if [[ $? != 0 ]]; then
	#additional delay so the user doesn't attempt to re-run the command too soon (otherwise the Finder might crash)
	sleep $delayErrorReopen;
	#
	echo 'An error occured when opening the new directory in Finder.';
	echo "Reverting to previous directory $prevDir";
	cd - > /dev/null;
	echo 'Please try again.';
	#ensure the terminal stays in the foreground (in case Finder opens but an error is thrown nonetheless)
	open –a terminal;
	return 1;
    fi
    #
    # Step 5: if re-open was successful and cd was done to a different directory than the previous one, update the recent history file
    currentDir=`pwd`;
    clear;
    echo "Previous directory: $prevDir";
    echo "Opened directory: $currentDir";
    if [[ $currentDir == $prevDir ]]; then
	echo 'The current directory remains unchanged!';
	open -a terminal;
	return 0;
    fi
    nrOfRows=`wc -l "$r_hist_file" | awk '{print $1;}'`;
    matchedRow=`grep -xn "$currentDir" "$r_hist_file"`;
    #remove previous current directory path from history file if path is contained
    if [[ $? == 0 ]]; then
	matchedRowNr=`echo $matchedRow | cut -f 1 -d : `;
	sed "$matchedRowNr"'d' "$r_hist_file" > "$temp_file";
    #if number of rows is at maximum, remove a row to make room for the new entry
    elif [[ $nrOfRows -eq $rHistMaxRows ]]; then
	sed "$rHistMaxRows"'d' "$r_hist_file" > "$temp_file";
    #copy the history file to temporary file to maintain consistency with above cases
    else
	cp "$r_hist_file" "$temp_file";
    fi
    echo $currentDir > "$r_hist_file";
    cat "$temp_file" >> "$r_hist_file";
    rm "$temp_file";
    #
    # Step 6: check if the entry already exists in the persistent history file
    # - if yes: update the persistent history file, then sort it in reverse order by number of visits
    # - if not, check if included in excluded history file
    #   - if yes: update the excluded history file by incrementing the number of visits for the directory (no sorting required)
    #   - if not: add the entry to persistent history file and sort the file
    #
    # #use the ';' separator for the grep in order to avoid multiple matches
    pHistMatchedRow=`grep "$currentDir"';' "$p_hist_file"`;
    #
    if [[ $? == 0 ]]; then
	extractedPath=`echo $pHistMatchedRow | cut -f 1 -d ';'`;
	visitsCount=`echo $pHistMatchedRow | cut -f 2 -d ';'`;
	let "visitsCount=visitsCount+1";
	pHistReplacingRow="$extractedPath"';'"$visitsCount";
	grep -v "$pHistMatchedRow" "$p_hist_file" > "$temp_file";
	echo "$pHistReplacingRow" >> "$temp_file";
	sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
    else
	eHistMatchedRow=`grep "$currentDir"';' "$e_hist_file"`;
	if [[ $? == 0 ]]; then
	    extractedPath=`echo $eHistMatchedRow | cut -f 1 -d ';'`;
	    visitsCount=`echo $eHistMatchedRow | cut -f 2 -d ';'`;
	    let "visitsCount=visitsCount+1";
	    eHistReplacingRow="$extractedPath"';'"$visitsCount";
	    grep -v "$eHistMatchedRow" "$e_hist_file" > "$temp_file";
	    echo "$eHistReplacingRow" >> "$temp_file";
	    mv "$temp_file" "$e_hist_file";
	else
	    echo "$currentDir"';1' >> "$p_hist_file";
	    sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	    mv "$temp_file" "$p_hist_file";
	fi
    fi
    #
    # Step 7: consolidate the recent and persistent history into a single file so the user can see both of them in the history menu
    cat "$r_hist_file" > "$hist_file";
    head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
    # no matter how the function works the terminal must remain the active window after the script finishes execution
    open -a terminal;
}
#
# ******************************************************************************************************************
#
# This function reads a line either from the favorites or the history file and feeds it as argument to the goto function so the user navigates to that directory
function goToMenu {
    # Helper functions for display
    #
    # formats the content of the consolidated history file or the favorites file; output is written into a file that is used by one of the display functions listed below
    function formatFileContent {
	input_file=$1;
	> "$format_file";
	while read currentEntry;
	do
	    currentEntryFormatted=`basename "$currentEntry"`':     '"$currentEntry";
	    echo "$currentEntryFormatted" >> "$format_file";
	done < "$input_file"
	column -t -s ':' "$format_file" > "$temp_file";
	mv "$temp_file" "$format_file";
    }
    #displays the consolidated history menu in a convenient manner for the user
    function displayHistory {
	tempVar1=`wc -l "$r_hist_file"`;
	tempVar2=`wc -l "$hist_file"`;
	rHistEntries=`echo $tempVar1 | cut -f 1 -d ' '`;
	histEntries=`echo $tempVar2 | cut -f 1 -d ' '`;
	let pHistEntries=histEntries-rHistEntries;
	formatFileContent "$hist_file";
	clear;
	echo 'NAVIGATION HISTORY';
	echo;
	echo '-- RECENTLY VISITED DIRECTORIES --';
	echo;
	cat -n "$format_file" | head -"$rHistEntries";
	echo;
	echo '--   MOST VISITED DIRECTORIES   --';
	echo;
	cat -n "$format_file" | tail -"$pHistEntries";
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	if [[ -s "$fav_file" ]]; then
	    echo 'Enter t or T to toggle to the favorite directories menu.';
	fi
	echo 'Enter cMenu (case-sensitive) to clear the navigation history menu.';
	echo 'Enter q or Q to quit.';
	echo;
    }
    #displays the favorites menu in a different (tailor-made) manner from the history menu
    function displayFavorites {
	formatFileContent "$fav_file";
	clear;
	echo 'FAVORITE DIRECTORIES';
	echo;
	cat -n "$format_file";
	echo;
	echo 'Enter the number of the directory you want to navigate to.';
	if [[ -s "$hist_file" ]]; then
	    echo 'Enter t or T to toggle to the navigation history menu.';
	fi
	echo 'Enter cMenu (case-sensitive) to clear the favorite directories menu.';
	echo 'Enter q or Q to quit.';
	echo;
    }
    # handles the case when the directory chosen for visiting does not exist
    function handleMissingDirectory {
	clear;
	echo "Invalid path $dirPath";
	echo 'The directory might have been moved or deleted.';
	while [[ '1' == '1' ]]; do
	    echo;
	    echo 'Please choose the required action: ';
	    echo 'r or R: remove the directory from the menus';
	    echo 'm or M: map to an existing directory';
	    echo 'q or Q: quit';
	    echo;
	    read userChoice;
	    # user chooses to remove the entry from menus (consolidated history and/or favorites)
	    if [[ $userChoice == 'r' ]] || [[ $userChoice == 'R' ]]; then
		# ensure the entry is removed from recent history (if there)
		grep -xv "$dirPath" "$r_hist_file" > "$temp_file";
		mv "$temp_file" "$r_hist_file";
		# ensure the entry is removed from persistent history (if there)
		grep -v "$dirPath"';' "$p_hist_file" > "$temp_file";
		sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
		rm "$temp_file";
		# ensure the entry is removed from favorites file (if there)
		grep -v "$dirPath"';' "$e_hist_file" > "$temp_file";
		mv "$temp_file" "$e_hist_file";
		grep -xv "$dirPath" "$fav_file" > "$temp_file";
		mv "$temp_file" "$fav_file";
		# history should be consolidated again
		cat "$r_hist_file" > "$hist_file";
		head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
		# confirm removal has been successfully performed
		echo "Entry $dirPath has been removed from the menus.";
		return 0;
	    # user chooses to replace the directory entry with another (existing) path
	    elif [[ $userChoice == 'm' ]] || [[ $userChoice == 'M' ]]; then
		clear;
		echo 'Enter the name of the replacing directory: ';
		read replacingDir;
		# the mapping directory should exist and be a valid directory
		if [[ ! -d "$replacingDir" ]]; then
		    echo "Directory $replacingDir does not exist or has been deleted.";
		    echo "Cannot map the missing directory $dirPath.";
		    return 1;
		fi
		# ensure the absolute path of the replacing directory is obtained (we need it to grep into the files)
		cd "$replacingDir";
		replacingDir=`pwd`;
		cd - > /dev/null;
		# identify the file where the path of the directory to be replaced lives
		grep "$dirPath"';' "$e_hist_file" > /dev/null;
		if [[ $? == 0 ]]; then
		    replaced_dir_file="$e_hist_file";
		else
		    replaced_dir_file="$p_hist_file";
		fi
		# check if the replacing dir is part of consolidated history, favorites file or none of them (not yet visited or added to favorites)
		visits_file=''; # the file where the number of visits of the replacing directory will be looked for (no file if not yet visited or added to favorites)
		foundEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		if [[ $? == 0 ]]; then
		    visits_file="$p_hist_file";
		else
		    foundEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		    if [[ $? == 0 ]]; then
			visits_file="$e_hist_file";
		    fi
		fi
		# get number of times the replacing directory has been visited (-1 if not visited/not added to favorites)
		if [[ "$visits_file" == "$p_hist_file" ]]; then
		    replacingDirEntry=`grep "$replacingDir"';' "$p_hist_file"`;
		    replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
		elif [[ "$visits_file" == "$e_hist_file" ]]; then
		    replacingDirEntry=`grep "$replacingDir"';' "$e_hist_file"`;
		    replacingDirVisits=`echo $replacingDirEntry | cut -f 2 -d ';'`;
		else
		    replacingDirVisits='-1';
		fi
		# remove the entry from recent history (if there)
		grep -v "$dirPath" "$r_hist_file" > "$temp_file";
		mv "$temp_file" "$r_hist_file";
		# do the actual mapping operation
		replacedDirMatchedRow=`grep "$dirPath"';' "$replaced_dir_file"`;
		replacedDirVisits=`echo $replacedDirMatchedRow | cut -f 2 -d ';'`;
		# - case 1: the replacing directory is not contained in the files (not yet visited/not yet added to favorites) - just do a path replacement
		if [[ $replacingDirVisits == '-1' ]]; then
		    replacedDirReplacingRow="$replacingDir"';'"$replacedDirVisits";
		    grep -v "$replacedDirMatchedRow" "$replaced_dir_file" > "$temp_file";
		    echo "$replacedDirReplacingRow" >> "$temp_file";
		    mv "$temp_file" "$replaced_dir_file";
		    # if missing dir had been in the persistent history file: re-sort file
		    if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
			sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
			mv "$temp_file" "$p_hist_file";
			# if missing dir had been in the excluded history file: re-create favorites file after update
		    else
			cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    fi
		# - case 2: the replacing directory is contained either in the persistent history file or in the favorites file
		else
		    # if the number of visits of the dir to be replaced exceeds the one of the replacing dir, then update the number of visits of the replacing dir to the higher figure
		    if [[ $replacingDirVisits -lt $replacedDirVisits ]]; then
			replacingDirPath=`echo $replacingDirEntry | cut -f 1 -d ';'`;
			replacingDirReplacingRow="$replacingDirPath"';'"$replacedDirVisits";
			grep -v "$replacingDirEntry" "$visits_file" > "$temp_file";
			echo "$replacingDirReplacingRow" >> "$temp_file";
			mv "$temp_file" "$visits_file";
		    fi
		    # remove the replaced directory from its file (either persistent history or excluded history file
		    grep -v "$dirPath"';' "$replaced_dir_file" > "$temp_file";
		    mv "$temp_file" "$replaced_dir_file";
		    # if missing dir had been in the persistent history file: re-sort file
		    if [[ "$replaced_dir_file" == "$p_hist_file" ]]; then
			sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
			mv "$temp_file" "$p_hist_file";
			# if missing dir had been in the excluded history file: re-create favorites file after update
		    else
			cat "$e_hist_file" | cut -f 1 -d ';' > "$fav_file";
		    fi
		fi
		# history should be consolidated again
		cat "$r_hist_file" > "$hist_file";
		head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
		# confirm mapping has been successfully performed
		echo "Missing directory: $dirPath";
		echo "Replacing directory: $replacingDir";
		echo 'Mapping performed successfully.';
		return 0;
	    elif [[ $userChoice == 'q' ]] || [[ $userChoice == 'Q' ]]; then
		clear;
		echo "You exited the $menuType menu.";
		return 0;
	    else
		clear;
		echo 'Invalid option! Please try again.';
	    fi
	done
    }
    # unsets all helper functions so they are not accessible by user from CLI
    # should be called before the main function returns, otherwise the helpers might become inaccessible earlier than required
    # the unsetHelpers function should be itself unset (right after it runs)
    function unsetHelpers {
	unset -f formatFileContent;
	unset -f displayHistory;
	unset -f displayFavorites;
	unset -f handleMissingDirectory;
    }
    #
    # Step 0: choose the file to be used for navigating, check if it is empty, then display it and prompt the user to enter the number of the entry that contains the path the user wants to navigate to
    if [[ "$1" == '-f' ]]; then
	input_file="$fav_file";
	display='displayFavorites';
	menuType='favorites';
    else
	input_file="$hist_file";
	display='displayHistory';
	menuType='history';
    fi
    # ensure the file exists (even if empty) to prevent any bugs
    touch "$input_file";
    if [[ ! -s "$input_file" ]]; then
	echo "There are no entries in the $menuType menu.";
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    eval "$display";
    read dirNr;
    #
    # Step 1: check the input entered by user. If should be either:
    # - a number between 1 and and the number of entries contained in the file
    # - a character that triggers flushing the content of the favorites/history file, switching to the other file or quitting the function
    tempVar=`wc -l "$input_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    while [[ '1' == '1' ]];
    do
	# check if the user chose one of the entries from the history or favorites file
	if [[ $dirNr =~  $nonNegativeInteger     ]] &&
	   [[ $dirNr -ge 1                       ]] &&
	   [[ $dirNr -le $currentNumberOfEntries ]]; then
	    break;
	# user chooses to quit the function
	elif [[ $dirNr == 'q' ]] || [[ $dirNr == 'Q' ]]; then
	    clear;
	    echo "You exited the $menuType menu.";
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 0;
	# toggle to the other menu if the user chooses so
	elif [[ $dirNr == 't' ]] || [[ $dirNr == 'T' ]]; then
	    if [[ "$1" == '-f' ]]; then
		if [[ ! -s "$hist_file" ]]; then
		    eval "$display";
		    echo 'Toggling disabled: no entries in the history menu.';
		    echo 'Please enter one of the valid options listed above.';
		    echo;
		    read dirNr;
		else
		    goToMenu;
		    unsetHelpers 2> /dev/null;
		    unset -f unsetHelpers;
		    return $?;
		fi
	    else
		if [[ ! -s "$fav_file" ]]; then
		    eval "$display";
		    echo 'Toggling disabled: no entries in the favorites menu.';
		    echo 'Please enter one of the valid options listed above.';
		    echo;
		    read dirNr;
		else
		    goToMenu -f;
		    unsetHelpers 2> /dev/null;
		    unset -f unsetHelpers;
		    return $?;
		fi
	    fi
	# clear history or the favorites if the user chooses so
	elif [[ $dirNr == 'cMenu' ]]; then
	    if [[ "$1" == '-f' ]]; then
		> "$fav_file";
		# if favorites are erased, the content of the excluded history file (except unvisited dirs) should return to the persistent history file
		grep -v ';0' "$e_hist_file" >> "$p_hist_file";
		> "$e_hist_file";
		# as usual re-sort persistent history file when modifying it
		sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
		mv "$temp_file" "$p_hist_file";
		# history should be consolidated again
		cat "$r_hist_file" > "$hist_file";
		head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
	    else
		> "$hist_file";
		> "$r_hist_file";
		> "$p_hist_file";
	    fi
	    clear;
	    echo "Content of $menuType menu has been erased.";
	    unsetHelpers 2> /dev/null;
	    unset -f unsetHelpers;
	    return 0;
	else
	    eval "$display";
	    echo 'Invalid option! Please try again.';
	    echo;
	    read dirNr;
	fi
    done
    #
    # Step 2: read the line from the input file
    dirPath=`sed "$dirNr"'q;d' "$input_file"`;
    #
    # Step 3: if the line of the input file contains a valid directory path, then visit the directory
    if [[ ! -d "$dirPath" ]]; then
	handleMissingDirectory;
	unsetHelpers 2> /dev/null;
	unset -f unsetHelpers;
	return 1;
    fi
    goToDir "$dirPath";
    unsetHelpers 2> /dev/null;
    unset -f unsetHelpers;
    return 0; 
}
#
# ******************************************************************************************************************
#
# used for returning to the previously visited directory without needing to access the history or favorites menus
function goToPrevDir {
    if [[ $prevDir == '' ]]; then
	echo 'Cannot jump to previous directory.';
	echo 'No directory visited in the current session.';
	return 1;
    fi
    goToDir "$prevDir";
    return 0;
}
#
# ******************************************************************************************************************
#
# used for adding a directory (either the current one or another) to favorites
function addToFavorites {
    #
    # Step 1: check if the user entered an argument or not
    # - the argument is a relative/absolute path of a directory that should be added to the favorite dirs (if it exists)
    # - if no argument was entered, the current directory will be added to favorites
    if [[ ! -z "$1" ]]; then
	if [[ ! -d "$1" ]]; then
	    echo "Directory $1 does not exist or has been deleted.";
	    echo 'Cannot add to favorites.';
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
	cd "$1";
	dirToAdd=`pwd`;
	cd - > /dev/null;
    else
	dirToAdd=`pwd`;
    fi
    #
    # Step 2: append the path to the favorites file (create it if it does not exist)
    #
    # helper function that moves the entry from the persistent history file to the excluded history file
    function excludeFromPersistentHistory {
	# check if the entry is included in the persistent history file (if yes, move to the excluded history file and re-sort the persistent history file)
	entryToExclude=`grep "$dirToAdd"';' "$p_hist_file"`;
	if [[ $? == 0 ]]; then
	    grep -v "$entryToExclude" "$p_hist_file" > "$temp_file";
	    # normally sorting would not be required (the persistent history file is already sorted and should remain so; it's just a safety precaution)
	    sort -n -r -k2 -t ';' "$temp_file" > "$p_hist_file";
	    rm "$temp_file";
	    # history should be consolidated again
	    cat "$r_hist_file" > "$hist_file";
	    head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
	    # update excluded history file
	    echo $entryToExclude >> "$e_hist_file";
	else
	    # if file is not already included in persistent history, just add it to the excluded history file (with number of visits 0 as the directory hasn't been visited yet)
	    echo "$dirToAdd"';0' >> "$e_hist_file";
	fi
    }
    #
    # finally add the directory to favorites
    if [[  -f "$fav_file" ]]; then
	grep -x "$dirToAdd" "$fav_file" > /dev/null;
	if [[ $? != 0 ]]; then
	    echo $dirToAdd >> "$fav_file";
	    echo "Directory $dirToAdd added to favorites.";
	    excludeFromPersistentHistory;
	    unset -f excludeFromPersistentHistory;
	    return 0;
	else
	    echo "Directory $dirToAdd already added to favorites.";
	    unset -f excludeFromPersistentHistory;
	    return 1;
	fi
    else
	echo $dirToAdd >> "$fav_file";
	echo "Directory $dirToAdd added to favorites.";
	excludeFromPersistentHistory;
	unset -f excludeFromPersistentHistory;
	return 0;
    fi
}
#
# ******************************************************************************************************************
#
# this function removes the entry from favorites and moves it back to persistent history
function removeFromFavorites {
    #
    # Step 1: check if the favorites file exists and is not empty
    if [[ ! -f "$fav_file" ]]; then
	echo "The favorites file $fav_file does not exist or has been deleted.";
	echo 'Please add a directory to favorites and then try again.';
	unset -f displayFavoritesFile;
	return 1;
    fi
    if [[ ! -s "$fav_file" ]]; then
	echo "File $fav_file is empty!";
	echo 'Nothing to remove';
	unset -f displayFavoritesFile;
	return 1;
    fi
    #
    # Step 2: display the file and prompt the user to choose the line to be deleted
    function displayFavoritesFile {
	clear;
	cat -n "$fav_file";
	echo;
	echo 'Enter the number of the entry to be removed';
	echo 'Enter q or Q to quit';
	echo;
    }
    displayFavoritesFile;
    read dirNr;
    #
    # Step 3: check the input entered by user. If should be either:
    # - a number between 1 and and the number of entries contained in the file
    # - a character that triggers quitting the function
    tempVar=`wc -l "$fav_file"`;
    currentNumberOfEntries=`echo $tempVar | cut -f 1 -d ' '`;
    while [[ '1' == '1' ]];
    do
	if [[ $dirNr =~  $nonNegativeInteger     ]] &&
	       [[ $dirNr -ge 1                       ]] &&
	       [[ $dirNr -le $currentNumberOfEntries ]]; then
	    break;
	elif [[ $dirNr == 'q' ]] || [[ $dirNr == 'Q' ]]; then
	    clear;
	    echo 'No entry removed from favorites.';
	    unset -f displayFavoritesFile;
	    return 0;
	else
	    displayFavoritesFile;
	    echo 'Invalid option! Please try again.';
	    echo;
	    read dirNr;
	fi
    done
    #
    # Step 4: remove the entry from the excluded history file
    favDirToRemove=`sed "$dirNr"'q;d' "$fav_file"`;
    exclDirToRemove=`grep "$favDirToRemove"';' "$e_hist_file"`;
    visitsCount=`echo "$exclDirToRemove" | cut -f 2 -d ';'`;
    grep -v "$exclDirToRemove" "$e_hist_file" > "$temp_file";
    mv "$temp_file" "$e_hist_file";
    # Also move the entry back to the persistent history file if it has at least one visit
    if [[ $visitsCount -gt 0 ]]; then
	echo $exclDirToRemove >> "$p_hist_file";
	# Always sort the persistent history file when it is modified
	sort -n -r -k2 -t ';' "$p_hist_file" > "$temp_file";
	mv "$temp_file" "$p_hist_file";
	# history should be consolidated again
	cat "$r_hist_file" > "$hist_file";
	head -"$pHistMaxRows" "$p_hist_file" | cut -f 1 -d ';' >> "$hist_file";
    fi
    #
    # Step 5: delete the entry
    sed "$dirNr"'d' "$fav_file" > "$temp_file";
    mv "$temp_file" "$fav_file";
    clear;
    echo "Entry $favDirToRemove removed from the favorites menu.";
}
#
# ******************************************************************************************************************
#
# This function is used to enter navigation mode
# In this mode the user can repeatedly visit directories by only entering the name of each folder (absolute path, relative path - including wildcards)
# It is also possible to access other functions like history/favorites, goto previous directory etc.
function navigate {
    clear;
    echo 'Welcome to navigation mode!';
    while [[ '1' == '1' ]]; do
	echo;
	echo '**************************************************'
	echo;
	echo 'Enter the path of the directory you want to visit (press RETURN for home directory). ';
	echo;
	echo 'Current directory:';
	echo;
	echo `pwd`;
	echo;
	echo 'Other available options (case-sensitive): ';
	echo;
	echo ':  -  enter a command';
	echo ':h - enter history menu';
	echo ':a - add current directory to favorites';
	echo ':r - remove a directory from favorites';
	echo ':f - enter favorites menu';
	echo ':p - go to the previously visited directory';
	echo ':q - quit navigation mode';
	echo;
	read dir_to_visit;
	clear;
	if [[ $dir_to_visit == ':' ]]; then
	    echo 'Enter the required command (press ENTER to quit):';
	    read command;
	    if [[ -z "$command" ]]; then
		clear;
		echo 'No command entered. You returned to navigation menu';
	    fi
	    eval "$command";
	elif [[ $dir_to_visit == ':h' ]]; then
	    goToMenu;
	elif [[ $dir_to_visit == ':f' ]]; then
	    goToMenu -f;
	elif [[ $dir_to_visit == ':a' ]]; then
	    addToFavorites;
	elif [[ $dir_to_visit == ':r' ]]; then
	    removeFromFavorites;
	elif [[ $dir_to_visit == ':p' ]]; then
	    goToPrevDir;
	elif [[ $dir_to_visit == ':q' ]]; then
	    echo 'You exited navigation mode.';
	    return 0;
	else
	    goToDir `echo "$dir_to_visit"`;
	fi
    done
}
#
#
#
#
# *****************************************************************************************************************
#
# Disable all "private" functions so they cannot be accessed by user from CLI
# These functions are only helper functions that are used by the global functions in order to perform specific operations
# Direct access from user side might cause unexpected behavior
# In addition to this "global disable" (which is run only once when the file is loaded by shell) the private functions also need to be disabled each time they are used
#
unset -f formatFileContent;
unset -f displayHistory;
unset -f displayFavorites;
unset -f handleMissingDirectory;
unset -f excludeFromPersistentHistory;
unset -f displayFavoritesFile;
#
#
#
#
# *****************************************************************************************************************
#
# Naming conventions used in this file:
# - variables containing path of working files (e.g. $p_hist_file): to be named using Python convention (underscore)
# - all other variables and all functions: to be named using lower camelCase convention
